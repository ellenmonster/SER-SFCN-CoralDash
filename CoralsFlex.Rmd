---
title: "SFCN Coral Reefs"
output:
  flexdashboard::flex_dashboard:
    vertical_layout: scroll
    orientation: columns
    theme: sandstone   # theme options: default, cosmo, bootstrap, cerulean, journal, flatly, readable, spacelab, united, lumen, paper, sandstone, simplex, yeti
runtime: shiny
---

```{r global, include=FALSE}

rm(list=ls())

### Load libraries -----
# Will automatically install any packages it can't find

pkgList <- c("flexdashboard", "shiny", "knitr", "gridExtra", "shinyWidgets", "leaflet", "plotly", "DT", "parallel", "rtf", "lubridate", "leaflet.minicharts", "multidplyr", "tidyverse", "htmlwidgets", "RSQLite", "multidplyr", "Rcpp", "reactable", "scales")
inst <- pkgList %in% installed.packages()
if (length(pkgList[!inst]) > 0) install.packages(pkgList[!inst],dep=TRUE)
lapply(pkgList, library, character.only = TRUE)

options(shiny.maxRequestSize = 20*1024^2) # allows data files up to 20 MB to be imported
source("Corals.R")

rv <- reactiveValues(CalcRepSites = NULL, Warn_list = NULL, PC_options = NULL, PC_Site = NULL, SS_PointCount = NULL, SS_PercCov = NULL, RC_Site = NULL, Bleach = NULL, mapdat = NULL, coraldat = NULL)

rv_param_temp <- reactiveValues(dat_PC = NULL, PC_avail_sublevs = NULL, dat_RC = NULL)
```

```{r action_button_import_new_data}
observeEvent(eventExpr = input$button_import, {
  if(is.null(input$filenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No coral data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$filenam$datapath), message = FALSE))
  
  if(is.null(input$sitesfilenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No sites data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$sitesfilenam$datapath), message = FALSE))
                
  withProgress(message = "Please be patient. Calculating something wonderful...", value = 0, {
    FuncCorals(filenam = input$filenam$datapath, sitesfilenam = input$sitesfilenam$datapath, out_prefix = input$out_prefix, run_parallel = input$use_parallel, set_cores = input$num_cores)
    
    rv_param_temp <- reactiveValues(dat_PC = NULL, PC_avail_sublevs = NULL, dat_RC = NULL)
    
     showModal(modalDialog(
        title = "Done",
        paste0("A summary RDS file has been saved as '", input$out_prefix, ".RDS' in the current working directory, ", getwd(), ". You may now select it for viewing (use the input box below, titled 'Select a summary RDS file')")
      ))
    })
})
```

```{r action_load_RDS}
observeEvent(eventExpr = input$summaryfile, {
  out <- readRDS(input$summaryfile$datapath)
  shiny::validate(need(names(out) == names(rv), message = paste0("DATA PROCESSING ERROR: The loaded file needs to have these and only these list elements: ", paste(names(rv), collapse = ", "), ". Please try with another file.")))
 
  rv <- sapply(names(out), FUN = function(i) {rv[[i]] <- out[[i]]}, simplify = FALSE)
  # rv$CalcRepSites <- out$CalcRepSites
  # rv$Warn_list <- out$Warn_list
  # rv$PC_options <- out$PC_options
  # rv$PC_Site <- out$PC_Site
  # rv$SS_PointCount <- out$SS_PointCount
  # rv$SS_PercCov <- out$SS_PercCov
  # rv$RC_Site <- out$RC_Site
  # rv$Bleach <- out$Bleach
  # rv$mapdat <- out$mapdat
  # rv$coraldat <- out$coraldat
  
  rv_param_temp <- reactiveValues(dat_PC = NULL, PC_avail_sublevs = NULL, dat_RC = NULL)
  
  Sys.sleep(0.25)
  
  showModal(modalDialog(
  title = "Done",
  "You may now navigate to the other tabs for summary graphs and tables"
  ))
})
```

```{r action_buttons_select_sublevels}
observeEvent(eventExpr = input$sublev_all_button, {
  shiny::req(!is.null(rv_param_temp$PC_avail_sublevs))
  updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$PC_avail_sublevs, selected = rv_param_temp$PC_avail_sublevs)
  })

observeEvent(eventExpr = input$sublev_none_button, {
  shiny::req(!is.null(rv_param_temp$PC_avail_sublevs))
  updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$PC_avail_sublevs, selected = character(0))
  })

observeEvent(eventExpr = input$sublev_esa_button, {
  shiny::req(!is.null(rv_param_temp$PC_avail_sublevs), !is.null(input$sel_lev))
  if(input$sel_lev == "Taxon") {
    updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$PC_avail_sublevs, selected = intersect(c("ACER", "APAL", "DCYL", "OANN", "OFAV", "OFRA"), rv_param_temp$PC_avail_sublevs)) # select all ESA taxa that are among the available sublevels
  } else { # The ESA button should only show when grouping level is 'Taxon', but including this 'else' just in case
    showModal(modalDialog(
      title = "ESA not available",
    "This option is only available when selected grouping level is 'Taxon'."
    ))
  }
  })
```

```{r action_button_export_PC}
observeEvent(eventExpr = input$button_export_PC, {
  shiny::req(!is.null(rv_param_temp$dat_PC), !is.null(input$sel_metric), !is.null(input$sel_error), !is.null(input$sel_lev), !is.null(input$sel_sublev))
    dat_export <- rv_param_temp$dat_PC 
    colnames(dat_export)[colnames(dat_export)=="y_val"] <- input$sel_metric
    colnames(dat_export)[colnames(dat_export)=="y_low"] <- paste0(input$sel_error, "_low")
    colnames(dat_export)[colnames(dat_export)=="y_high"] <- paste0(input$sel_error, "_high")
  
    write.csv(dat_export, paste0(input$sel_lev, "_", input$sel_sublev, "_perccov.csv"), row.names = FALSE)
    showModal(modalDialog(
    title = "Done",
    paste0("The data have been saved as ", input$sel_lev, "_", input$sel_sublev, "_perccov.csv in the current working directory, ", getwd())
    )
    )
})
```

```{r action_button_update_cover}
# Action to update cover summaries with current user inputs----
observeEvent(eventExpr = input$button_update_cover, {
  
  shiny::req(!is.null(rv$PC_Site), !is.null(input$sel_lev), !is.null(input$sel_summaryscale), !is.null(input$sel_sublev), !is.null(input$sel_showRSS), !is.null(input$sel_episodic), !is.null(input$sel_error), !is.null(input$sel_splitplot))
 
  dat_PC <- subset(rv$PC_Site[[input$sel_lev]], SiteLev == input$sel_summaryscale & Sublevel %in% input$sel_sublev & RSS %in% input$sel_showRSS)
 
  if(input$sel_episodic == FALSE) # remove episodic data
    dat_PC %<>% filter(Purpose == "Annual")
  
  if(input$sel_metric == "Mean" & input$sel_error == "95%CI")
    dat_PC2 <- dat_PC %>%
    select(RSS, Sublevel, Year, SurvDate, NumTransect, y_val = mean, y_low = mean_low95, y_high = mean_high95)
  
  if(input$sel_metric == "Mean" & input$sel_error == "SE")
    dat_PC2 <- dat_PC %>%
    mutate(
      y_low = mean - mean_SE, 
      y_high = mean + mean_SE) %>%
    select(RSS, Sublevel, Year, SurvDate, NumTransect, y_val = mean, y_low, y_high)
  
  rv_param_temp$dat_PC <- dat_PC2 %>% arrange(RSS, Sublevel, Year, SurvDate)
  
  shinyjs::hideElement("wp_cover_criteria")
})
```

```{r export_cover_table}
observeEvent(eventExpr = input$rtf_button, {
  rtffile <- rtf::RTF(paste0(input$sel_tabsite, "_", input$sel_tabsurv, ".doc"), width = 11, height = 8.5, font.size = 10, omi = c(1, 0.5, 1, 0.5))
  rtf::addHeader(rtffile, title = paste0(input$sel_tabsite, " (", input$sel_tabsurv, ")"), subtitle = "Point Counts", font.size = 14)
  rtf::addTable(rtffile, data_point(), col.justify = "C", header.col.justify = "C", row.names = TRUE)
  rtf::addPageBreak(rtffile, width = 10, height = 8.5, omi = c(1, 0.5, 1, 0.5))
  rtf::addHeader(rtffile, title = paste0(input$sel_tabsite, " (", input$sel_tabsurv, ")"), subtitle = "% Cover", font.size = 14)
  rtf::addTable(rtffile, data_perccov(), col.justify = "C", header.col.justify = "C", row.names = TRUE)
  rtf::done(rtffile)
  showModal(modalDialog(
    title = "Done",
    paste0("The tables have been saved as ", input$sel_tabsite, "_", input$sel_tabsurv, ".doc in the current working directory, ", getwd())
  ))
})
```
  
Import
======================================

Column {data-width=10}
-------------------------------------

Column {data-width=525}
-------------------------------------
#### <font size="5"> Instructions for processing a raw data file (jump to Step 6 if you already have a summary RDS file)</font> 

<font size="4"> 

1.  Create a coral data CSV file that summarizes the coral data by transect with these required columns (case-sensitive): *BleachingCode, Category, CountOfTaxonCode, Date, FunctionalGroup, Latitude, Longitude, ParkCode, Purpose, Site, SubCategory, TaxonCode, Transect, TripName, Year*    

2.  Create a sites data CSV file that links reporting sites with sites and specifies if the sites are still active. The required colums are (case-sensitive): *ParkCode, Site, ReportingSite, ReportingSiteName, IsActive* (where "ReportingSiteName" is the full name corresponding with "ReportingSite", and "IsActive" = 1 for active sites and 0 for inactive sites)

3.  For parallel (faster) processing, select the number of cores to use. Default is one less than the maximum number of cores detected on your computer.

4.  Enter a prefix to append to the output summary file.

5. Browse to and upload the coral and sites data files (CSV), then press the "Import and Process New Data" button.

6.  When data processing is completed, a summary data file will be output to the current working directory as an RDS with the name '(your prefix)_coralsummary.RDS'. PROCEED TO STEP #7 TO IMPORT THE NEWLY CREATED .RDS FILE.

</font> 

#### <font size="5"> Instructions for importing a summary RDS file</font> 

<font size="4"> 

7.  Browse to and import the '(your prefix)_coralsummary.RDS' file, to generate summaries in the plot and table tabs.

</font> 

Column {data-width=10}
-------------------------------------

Column {data-width=225}
-------------------------------------

### PROCESS A RAW CORAL DATA FILE {data-height=150}
```{r select_raw_data}
checkboxInput("use_parallel", label = "Use parallel processing?", value = TRUE)

numericInput("num_cores", label = "Number of processing cores to use: ", min = 1, max = detectCores(), step = 1, value = detectCores()-1, width = "100%")

textInput("out_prefix", label = "Prefix to append to output files: ", value = paste0("corals", gsub(pattern = "-", replacement = "", x = Sys.Date()), "_"), width = "100%")

fileInput("filenam", label = "Select a coral survey CSV file (make sure you've entered a file Prefix!)", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

fileInput("sitesfilenam", label = "Select a sites CSV file", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

actionButton("button_import", "IMPORT AND PROCESS NEW DATA", width = "100%")
```

### IMPORT A CORAL SUMMARY FILE {data-height=100}
```{r select_files}
fileInput("summaryfile", label = "Select a summary RDS file", accept = c('.RDS'), width = "100%")
  
# checkboxInput("plotwarn_on", label = "Show plot warnings", value = TRUE)
```

Data Warnings
====================================== 
Column
-------------------------------------
**SURVEY TRIPS WITH PURPOSE OTHER THAN "ANNUAL" OR "EPISODIC"**
*(These data are excluded from analyses)*
```{r warnings}

br()

renderTable({
  validate(need(!is.null(rv$Warn_list), message = FALSE))
  AltPurp <- rv$Warn_list$AltPurp
  validate(need(nrow(AltPurp) > 0, "No warnings to show"))
  AltPurp
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SURVEY TRIPS WITH MISSING TAXON CODES OR RECORDED AS "NO TAXON"**
```{r}
renderTable({
  validate(need(!is.null(rv$Warn_list), message = FALSE))
  NoTaxon <- rv$Warn_list$NoTaxon
  validate(need(nrow(NoTaxon) > 0, "No warnings to show"))
  NoTaxon
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SURVEY TRIPS WITH BLEACHING CODES ASSIGNED TO NON-CORAL TRANSECT HITS**
*(These data are excluded from bleaching analyses)*
```{r}
renderTable({
  validate(need(!is.null(rv$Warn_list), message = FALSE))
  BleachCode <- rv$Warn_list$BleachCode
  validate(need(nrow(BleachCode) > 0, "No warnings to show"))
  BleachCode
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SITE-SURVEYS WITH TRANSECT COUNTS OTHER THAN 4 OR 20**
```{r}
renderTable({
  validate(need(!is.null(rv$Warn_list), message = FALSE))
  TransCount <- rv$Warn_list$TransCount
  validate(need(nrow(TransCount) > 0, "No warnings to show"))
  TransCount$`Survey Date` <- as.character(lubridate::ymd(TransCount$`Survey Date`)) # renderTable does not play nice with dates--need to format as character
  TransCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH TOTAL TAXON COUNTS NOT DIVISIBLE BY 10**
```{r}
renderTable({
  validate(need(!is.null(rv$Warn_list), message = FALSE))
  TaxonCountDiv <- rv$Warn_list$TaxonCountDiv
  validate(need(nrow(TaxonCountDiv) > 0, "No warnings to show"))
  TaxonCountDiv
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH TOTAL TAXON COUNTS LESS THAN 200 OR GREATER THAN 480**
```{r}
renderTable({
  validate(need(!is.null(rv$Warn_list), message = FALSE))
  TaxonCount <- rv$Warn_list$TaxonCount
  validate(need(nrow(TaxonCount) > 0, "No warnings to show"))
  TaxonCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH SHADOW HITS EXCEEDING 5% OF TOTAL TAXON COUNTS**
```{r}
renderTable({
  validate(need(!is.null(rv$Warn_list), message = FALSE))
  ShadowCount <- rv$Warn_list$ShadowCount
  validate(need(nrow(ShadowCount) > 0, "No warnings to show"))
  ShadowCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH UNKNOWN ("UNK") HITS EXCEEDING 5% OF TOTAL TAXON COUNTS**
```{r}
renderTable({
  validate(need(!is.null(rv$Warn_list), message = FALSE))
  UNKCount <- rv$Warn_list$UNKCount
  validate(need(nrow(UNKCount) > 0, "No warnings to show"))
  UNKCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

% Cover
======================================  
Inputs {.sidebar data-width=275}
-------------------------------------
```{r input_cover1}
actionButton("button_update_cover", "Update Cover Summaries", style="background-color:#66CD00; color:black", width = "95%")
  
br()
  
br()
  
actionButton("button_export_PC", "Click to Export Plot Data", width = "95%")
  
br()

# shinyjs::hidden( # initially hide this well panel
wellPanel(
  id = "wp_cover_criteria",
  
  p(strong("Select summary criteria, then press 'Update Cover Summaries'")),
  
  radioButtons("sel_metric",
               label = "Metric to plot",
               choices = list("Median", "Mean"),
               selected = "Median",
               inline = TRUE),
  
  radioButtons("sel_error",
             label = "Bootstrapped error bars to plot",
             choiceNames = list("95%CI", "SE*"),
             choiceValues = list("95%CI", "SE"),
             selected = "95%CI",
             inline = TRUE),
    
    tags$div(renderText({ 
      shiny::req(!is.null(input$sel_error))
      if(input$sel_error == "SE") {
        paste0("WARNING!! SE is valid for % cover only if individual transect data are approximately normally distributed. SE error bars that extend below zero are one indication that SE calculations are not appropriate for your data.")  # Post a warning about using SE
        }
      }), style = "font-size:14px; color:red; font-weight:bold;"),
  
    # Pre-filter data
    checkboxInput("PCactive", label = "Only use active sites", value = FALSE),
    checkboxInput("sel_episodic", label = "Include episodic survey data", value = TRUE),
    
    # Select summary level
    radioButtons("sel_summaryscale", 
             label = "Summarize data at this level:", 
             choiceNames = list("Reporting Site", "Site"),
             choiceValues = list("RepSiteSurvID", "SiteSurvID"),
             selected = "SiteSurvID",
             inline = TRUE),

    tags$div(renderText({ 
      shiny::req(!is.null(input$sel_summaryscale))
      if(input$sel_summaryscale == "RepSiteSurvID") {
        paste0("NOTE: Summaries by Reporting Site are limited to active sites and begin on the first year for which data are available for all active sites")  # Explain how reporting sites are summarized
        }
      }), style = "font-size:14px; color:red; font-weight:bold;"),

    renderUI({
      shiny::req(!is.null(rv$mapdat), !is.null(input$sel_summaryscale), !is.null(input$PCactive))
      
      RSS_choices <- rv$mapdat %>%
        dplyr::filter(if(input$PCactive == TRUE) IsActive == 1 else TRUE) %>%
        {if(input$sel_summaryscale == "SiteSurvID") dplyr::select(., Site) else dplyr::select(., ReportingSite)} %>%
        dplyr::distinct() %>%
        pull() %>%
        as.character()

      checkboxGroupInput("sel_showRSS", label = paste0("Show results for these ", ifelse(input$sel_summaryscale == "RepSiteSurvID", "reporting sites", "sites")), choices = RSS_choices, selected = if(!is.null(input$sel_showRSS) & all(input$sel_showRSS %in% RSS_choices)) {input$sel_showRSS} else {RSS_choices}, inline = FALSE) # if selections already made and they are a subset of RSS_choices, then use those selections; otherwise, use RSS_choices as default
      }),
    
    # Select grouping level
    renderUI({
      shiny::req(!is.null(rv$PC_options$Level))
      
      selectInput("sel_lev", label = "Select grouping level", 
                  choices = levels(rv$PC_options$Level), 
                  selected = switch(is.null(input$sel_lev)+1, input$sel_lev, levels(rv$PC_options$Level)[1]))
      }),

    renderUI({
  shiny::req(!is.null(rv$PC_Site), !is.null(input$sel_lev), !is.null(input$sel_summaryscale), !is.null(input$sel_showRSS), !is.null(input$sel_episodic))
      rv_param_temp$PC_avail_sublevs <- subset(rv$PC_Site[[input$sel_lev]], SiteLev == input$sel_summaryscale & RSS %in% input$sel_showRSS) %>%
        dplyr::filter(if(input$sel_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
        pull(Sublevel) %>%
        as.character() %>%
        unique()
      
  sublev_default <- ifelse("CORAL" %in% rv_param_temp$PC_avail_sublevs, "CORAL", rv_param_temp$PC_avail_sublevs[1])

  checkboxGroupInput("sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$PC_avail_sublevs, selected = if(!is.null(input$sel_sublev) & all(input$sel_sublev %in% rv_param_temp$PC_avail_sublevs)) {input$sel_sublev} else {sublev_default}, inline = TRUE)
  }),

actionButton("sublev_all_button", "Select All", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),

actionButton("sublev_none_button", "Select None", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),

conditionalPanel(
  condition = "input.sel_lev == 'Taxon'",
  actionButton("sublev_esa_button", "Select ESA", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px")
)
) # end of 'wp_cover_criteria'
```
 
*\*Relative cover for functional groups may not sum to 100% because some coral species could not be assigned to a functional group.*
```{r input_cover2}
####### PICK UP FROM HERE--I'M COMBINING %COV AND %REL COV AND ALLOWING MULTIPLE SUBLEVELS AND/OR MULTIPLE SITES

renderUI({
  shiny::req(!is.null(input$sel_showRSS), !is.null(input$sel_sublev))

  selectInput("sel_splitplot", label = "In a single plot, show: ", choices = c("One sublevel, many locations" = "one_sub_many_loc", "One location, many sublevels" = "one_loc_many_sub", "One location, one sublevel" = "one_loc_one_sub"), selected = switch(is.null(input$sel_splitplot)+1, input$sel_splitplot, "one_sub_many_loc"), width = "95%")
})

numericInput("sel_ncols",
             label = "Arrange plots in how many columns?",
             value = 1,
             min = 1,
             max = 3,
             step = 1)

checkboxInput("PC_blackwhite", label = "Plot in grayscale (can only handle up to 6 categories)", value = FALSE)

numericInput("PCx_int", label = "Increment for x-axis ticks", min = 1, max = 5, step = 1, value = 1)

renderUI({
  numericInput("PCy_max", label = "Set y-axis maximum", min = 5, max = 105, step = 5, value = switch(is.null(input$PCy_max)+1, input$PCy_max, NULL))
})

# numericInput("PCy_int", label = "Increment for y-axis ticks", min = 5, max = 100, step = 5, value = 10)

textInput("PCplot_title", "Enter text to use for plot title", value = "")
```

Trends in Cover
-------------------------------------
### Summary of % Cover

####

```{r plot_PC}
output$out_cover_plot <- plotly::renderPlotly({
  shiny::req(!is.null(rv_param_temp$dat_PC), !is.null(input$sel_splitplot), !is.null(input$PC_blackwhite), !is.null(input$sel_metric), !is.null(input$sel_error), !is.null(input$sel_sublev), !is.null(input$sel_ncols))
  
  cbp1 <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7", "#0072B2", "#D55E00", "#999999", "#F0E442", "#000000", "chocolate4", "purple4", "chartreuse", "lightpink", "honeydew2") # Colorblind-friendly palette
  
if(input$sel_splitplot == "one_loc_one_sub") {
  plotly_PC <- 
    ggplot(data = rv_param_temp$dat_PC, aes(x = SurvDate, y = y_val, NumTransect = NumTransect, y_low = y_low, y_high = y_high), colour = "black") +
    geom_point()
  } else {
    plotly_PC <- 
      ggplot(data = rv_param_temp$dat_PC, aes_string(x = "SurvDate", y = "y_val", colour = ifelse(input$sel_splitplot == "one_loc_many_sub", "Sublevel", "RSS"), NumTransect = "NumTransect", y_low = "y_low", y_high = "y_high")) +
    geom_point()
  
  if(input$PC_blackwhite) {
    plotly_PC <- plotly_PC + scale_colour_grey()
  } else {
    plotly_PC <- plotly_PC +
      discrete_scale("fill", "manual", colorRampPalette(cbp1))
  }
}

  if(nrow(subset(rv_param_temp$dat_PC, NumTransect >=8)) > 0) {
    plotly_PC <- plotly_PC +
    geom_line(data = subset(rv_param_temp$dat_PC, NumTransect >= 8), linetype = "solid") +  # locs with at least 8 transects shown as solid line
    geom_errorbar(data = subset(rv_param_temp$dat_PC, NumTransect >= 8), aes(ymin = y_low, ymax = y_high), width = .25)
  }

  if(nrow(subset(rv_param_temp$dat_PC, NumTransect < 8)) > 0) {
    plotly_PC <- plotly_PC +
    geom_line(data = subset(rv_param_temp$dat_PC, NumTransect < 8), linetype = "dotted") # locs with <8 transects shown as dotted line and no error bars
  }

facet_vars <- switch(input$sel_splitplot,
                     "one_loc_one_sub" = "~ RSS + Sublevel",
                     "one_loc_many_sub" = "~ RSS",
                     "one_sub_many_loc" = "~ Sublevel")

default_title <- paste0(input$sel_metric,  "% Cover (", input$sel_error, ")")
  plotly_PC2 <- plotly_PC +
    expand_limits(y = switch(is.null(input$PCy_max)+1, c(0, input$PCy_max, 0), 0)) +
    scale_x_date(date_labels = "%Y", breaks = scales::pretty_breaks()) +
    labs(title = switch((nchar(input$PCplot_title)==0)+1, input$PCplot_title, default_title), x = "Year", y = paste0(input$sel_metric, " % Cover (", input$sel_error, ")")) +
    facet_wrap(as.formula(facet_vars), scales = "free_y", ncol = input$sel_ncols) +
    theme_bw(base_size = 12) +
    theme(legend.title = element_blank(),
          panel.spacing = unit(2, "lines"))
  
  facet_ht <- 260
  add_on_ht <- 120
  page_ht <- switch(input$sel_splitplot,
                     "one_loc_one_sub" = ceiling(length(input$sel_sublev) * length(input$sel_showRSS)/input$sel_ncols) * facet_ht + add_on_ht,
                     "one_loc_many_sub" = ceiling(length(input$sel_showRSS)/input$sel_ncols) * facet_ht + add_on_ht,
                     "one_sub_many_loc" = ceiling(length(input$sel_sublev)/input$sel_ncols) * facet_ht + add_on_ht
  )

  if(input$plotwarn_on) {
    gp <- ggplotly(plotly_PC2 +
                     labs(subtitle = "(NOTES: X-axis tick marks Jan. 1 of each year. If fewer than 8 transects, lines are dotted)"),
                   height = page_ht,
                   tooltip = c("RSS", "SurvDate", "NumTransect", "y_val", "y_low", "y_high")) # specify the total plot height here because this layout will be applied to the entire page
  } else {
    gp <- ggplotly(plotly_PC2, 
                   height = page_ht,
                   tooltip = c("RSS", "SurvDate", "NumTransect", "y_val", "y_low", "y_high"))
  }
  
  # Code to fix the duplicate legend entry problem that occurs when ggplotly is used on faceted ggplot with a scale_colour... or scale_fill... argument
  for (i in seq_along(gp$x$data)) {
  # Is the layer the first entry of the group?
  is_first <- grepl("^\\(.*?,1\\)", gp$x$data[[i]]$name)
  # Extract the group identifier and assign it to the name and legendgroup arguments
  gp$x$data[[i]]$name <- gsub("^\\((.*?),\\d+\\)", "\\1", gp$x$data[[i]]$name)
  gp$x$data[[i]]$legendgroup <- gp$x$data[[i]]$name
  # Show the legend only for the first layer of the group 
  if (!is_first) gp$x$data[[i]]$showlegend <- FALSE
}
gp
  
  gp[['x']][['layout']][['annotations']][[2]][['x']] <- -0.06 # move y-axis title more to the left
  gp[['x']][['layout']][['annotations']][[1]][['y']] <- -0.06 # move x-axis title down more
  gp %>% layout(
        margin = list(
          t=80,
          b=90,
          l= 70,
          r=5))
  
})

tags$style("#out_cover_plot{height:100vh;overflow-x:scroll;overflow-y:scroll}")
plotlyOutput("out_cover_plot")
```

####

```{r summarize_cover}
output$table_perc_cover <- renderReactable({
  
  shiny::req(!is.null(rv_param_temp$dat_PC))
  tab_perc_cov <- rv_param_temp$dat_PC 
  
  tab_perc_cov$SurvDate <- lubridate::ymd(tab_perc_cov$SurvDate)
    
  reactable(
    tab_perc_cov,
    columns = list(
      RSS = colDef(width = 100),
      Sublevel = colDef(width = 130),
      Year = colDef(name = "Survey Year", width = 100, align = "center"),
      SurvDate = colDef(name = "Survey Date", width = 100, align = "center"),
      NumTransect = colDef(name = "# of Transects", width = 100, align = "center"),
      y_val = colDef(name = input$sel_metric, width = 100, align = "center"),
      y_low = colDef(name = paste0(input$sel_error, "_low"), width = 100, align = "center"),
      y_high = colDef(name = paste0(input$sel_error, "_high"), width = 100, align = "center")
      ),
    columnGroups = list(
      colGroup(name = paste0(input$sel_metric, " Summary Across Transects"), columns = c("y_val", "y_low", "y_high"))
      ),
    resizable = TRUE, 
    filterable = TRUE,
    striped = TRUE,
    highlight = FALSE,
    showSortIcon = TRUE,
    compact = TRUE,
    bordered = TRUE,
    showPageSizeOptions = TRUE)
})
reactableOutput("table_perc_cover")
tags$style("#table_perc_cover{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Cover Table
====================================== 
Inputs {.sidebar data-width=250}
-------------------------------------
```{r input_tab}
checkboxInput("tabactive", label = "Show active sites only", value = FALSE, width = "95%")

renderUI({
  if(!is.null(rv$mapdat)) {
    tabsites <- rv$mapdat %>%
    {if (input$tabactive == TRUE) filter(., IsActive == 1) else filter(., IsActive %in% c(0,1))} %>%
      select(RSS = Site) %>%
      distinct()
    tabsites <- sort(as.character(tabsites$RSS))
    
    selectInput("sel_tabsite", label = "Select a site", choices = tabsites, selected = tabsites[1], width = "95%")
  }
})

renderUI({
  if(!is.null(rv$PC_Site) & !is.null(input$sel_tabsite)) {
    surv <- sort(unique(na.omit(rv$PC_Site$Taxon$SurvDate[rv$PC_Site$Taxon$RSS == input$sel_tabsite])))
    if(length(surv) > 0)
      sliderTextInput("sel_tabsurv", label = "Choose a survey", choices = surv, selected = max(surv), dragRange = FALSE, force_edges = TRUE, width = "95%")
  }
})

actionButton("rtf_button", "Click to Export Tables", width = "95%")

br()
br()
```
*\*Error (SE and 95% CI) is not calculated for sites with less than eight transects, or for sublevels with zero occurrences.*

```{r}
br() # Add blank lines to increase page height with a hack
br()
br()
br()
br()
br()
br()
```

Column {data-width=550;vertical_layout: scroll}
-------------------------------------
### Point Counts by SITE-SURVEY
  
```{r tab_point}
data_point <- reactive({
  if(!is.null(input$sel_tabsite) & !is.null(input$sel_tabsurv)) {
    req(unique(na.omit(rv$PC_Site$Taxon$RSS_SurvID[rv$PC_Site$Taxon$RSS == input$sel_tabsite & rv$PC_Site$Taxon$SurvDate == input$sel_tabsurv])), cancelOutput = TRUE)
  pointcov <- rv$SS_PointCount[[unique(na.omit(rv$PC_Site$Taxon$RSS_SurvID[rv$PC_Site$Taxon$RSS == input$sel_tabsite & rv$PC_Site$Taxon$SurvDate == input$sel_tabsurv]))]]
  pointcov
  }
  })

renderTable({
  validate(need(nrow(data_point()) > 0, message = FALSE))
  tab_pointcov <- data_point()
  }, align = "c", include.rownames=TRUE)
```

### % Cover by SITE-SURVEY

```{r tab_perccov}
data_perccov <- reactive({
  if(!is.null(input$sel_tabsite) & !is.null(input$sel_tabsurv)) {
   
    req(unique(na.omit(rv$PC_Site$Taxon$RSS_SurvID[rv$PC_Site$Taxon$RSS == input$sel_tabsite & rv$PC_Site$Taxon$SurvDate == input$sel_tabsurv])), cancelOutput = TRUE)
  perccov <- rv$SS_PercCov[[unique(na.omit(rv$PC_Site$Taxon$RSS_SurvID[rv$PC_Site$Taxon$RSS == input$sel_tabsite & rv$PC_Site$Taxon$SurvDate == input$sel_tabsurv]))]]
  perccov

  } 
  })

renderTable({
  validate(need(nrow(data_perccov()) > 0, message = FALSE))
  tab_perccov <- data_perccov()
  }, align = "c", include.rownames=TRUE)
```

Bleaching
======================================
Inputs {.sidebar data-width=200}
-------------------------------------
```{r input_bleach}

br()

radioButtons("sel_blsitelev", 
             label = "Site level to summarize", 
             choiceNames = list("Reporting Site", "Site"),
             choiceValues = list("RepSiteSurvID", "SiteSurvID"),
             selected = "SiteSurvID",
             inline = TRUE)

checkboxInput("blactive", label = "Show active sites only", value = FALSE)

renderUI({
  if(!is.null(rv$mapdat)) {
    blsites <- rv$mapdat %>%
    {if (input$blactive == TRUE) filter(., IsActive == 1) else filter(., IsActive %in% c(0,1))} %>%
    {if (input$sel_blsitelev == "SiteSurvID") select(., Site) else select(., ReportingSite)} %>%
      distinct()
    colnames(blsites) <- "RSS"
    blsites <- sort(as.character(blsites$RSS))
    
    selectInput("sel_blsite", label = "Select a (reporting) site", choices = blsites, selected = blsites[1])
  }
})
```
*\*Bar plots only show surveyed years*
``` {r input_bleach2}
checkboxInput("sel_blepisodic", label = "Include 'Episodic' trips", value = TRUE)

textInput("blplot_title", "Enter text to use for plot title", value = "") 
br()
```
*\*To export a bleach plot, right-click on the plot and select 'Save image as'*
  
Column {data-width=550}
-------------------------------------
### Coral Cover by Bleaching Code
  
```{r plot_bleachPC}
dat_bleach <- reactive({
  if(!is.null(rv$Bleach) & !is.null(input$sel_blsitelev) & !is.null(input$sel_blsite) & !is.null(input$sel_blepisodic)) {
  
  temp_bleach <- subset(rv$Bleach, SiteLev == input$sel_blsitelev & RSS == input$sel_blsite) %>%
    arrange(SurvDate)
  
  if (input$sel_blepisodic == FALSE) # remove episodic data
    temp_bleach %<>% filter(Purpose == "Annual")
  
  temp_bleach$SurvDate = as.factor(temp_bleach$SurvDate)
  temp_bleach}
})

renderPlot({
  validate(need(nrow(dat_bleach()) > 0, message = FALSE))

  plot_bleachPC <- 
    ggplot(dat_bleach(), aes(x = SurvDate, y = PC, fill = BleachingCode)) +
    geom_col(colour="black", size = 0.1, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = c("NoData" = "yellow", "UNBL" = "gray25", "BL1" = "gray45", "BL2" = "gray55", "BL3" = "gray75", "BL4" = "gray92")) +
    scale_y_continuous(expand = c(0, 0)) +
    labs(y = "% Cover of Site", subtitle = "For surveys from Oct. 2005 to present, coral data with NA entry for 'Bleaching Code' are considered 'Unbleached' (UNBL)") +
    theme_bw(base_size = 12) +
    facet_grid(. ~ Year, scales = "free_x", switch = "x") +
    theme(legend.title = element_blank(),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
          strip.text.x = element_text(size = 11),
          strip.background=element_blank(),
          panel.border = element_blank(),
          panel.grid = element_blank(),
          panel.spacing = unit(-0.05, "lines"))
  
  grid.arrange(plot_bleachPC, top = input$blplot_title)
})
```

### Proportion Bleaching

```{r plot_bleachRC}
renderPlot({
  validate(need(nrow(dat_bleach()) > 0, message = FALSE))
  
  plot_bleachRC <- 
    ggplot(dat_bleach(), aes(x = SurvDate, y = RC, fill = BleachingCode)) +
    geom_col(colour="black", size = 0.1, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = c("NoData" = "yellow", "UNBL" = "gray25", "BL1" = "gray45", "BL2" = "gray55", "BL3" = "gray75", "BL4" = "gray92")) +
    scale_y_continuous(expand = c(0, 0)) +
    labs(y = "% Cover of Coral", subtitle = "For surveys from Oct. 2005 to present, coral data with NA entry for 'Bleaching Code' are considered 'Unbleached' (UNBL)") +
    theme_bw(base_size = 12) +
    facet_grid(. ~ Year, scales = "free_x",  switch = "x") +
    theme(legend.title = element_blank(),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
          strip.text.x = element_text(size = 11),
          strip.background=element_blank(),
          panel.border = element_blank(),
          panel.grid = element_blank(),
          panel.spacing = unit(-0.05, "lines"))
  
  grid.arrange(plot_bleachRC, top = input$blplot_title)
})
```


Map
====================================== 
Inputs {.sidebar data-width=200}
-------------------------------------
```{r map_input}
renderUI({
  if(!is.null(rv$Bleach)) {
    sliderTextInput("sel_MapSurvey", force_edges = TRUE, label = "Choose a survey event", choices = sort(as.character(unique(rv$Bleach$SurvDate))), selected = , dragRange = FALSE, width = "85%")
  }
})
br()

checkboxInput("MapActive", label = "Show active sites only", value = FALSE)

br()

radioButtons("sel_MapMetric", 
             label = "Metric to map:", 
             choiceNames = list("% coral cover", "% cover by bleach level"),
             choiceValues = list("PercCoral", "BleachRC"),
             selected = "PercCoral")
```

Column {data-width=550 vertical_layout: fill}
-------------------------------------
*NOTE:  For surveys from Oct. 2005 to present, coral data with NA entry for 'Bleaching Code' are considered 'Unbleached' (UNBL)*
```{r maps}
output$coralmap = renderLeaflet({
  if(!is.null(input$sel_MapSurvey)) {
    validate(need(!is.null(rv$mapdat), message = "Map data have not been processed."))
    
    if(input$MapActive) {
    MapDat_df <- rv$mapdat %>%
      filter(IsActive == TRUE)
    } else {
      MapDat_df <- rv$mapdat
    }
    
    minLong <- min(MapDat_df$medLong, na.rm = TRUE)
    minLat <- min(MapDat_df$medLat, na.rm = TRUE)
    maxLong <- max(MapDat_df$medLong, na.rm = TRUE)
    maxLat <- max(MapDat_df$medLat, na.rm = TRUE)
    
    MapDat2_df <- MapDat_df %>%
     filter(SurvDate == input$sel_MapSurvey) %>%
     select(-c(ReportingSiteName, ReportingSite, IsActive, minyr, maxyr))
  
  basemap <- leaflet() %>%
     addProviderTiles("Esri.NatGeoWorldMap")
  
  if(input$sel_MapMetric == "PercCoral") {
     chartmap <- basemap %>%
       addMinicharts(
         lng = MapDat_df$medLong,
         lat = MapDat_df$medLat,
         type = "pie",
         width = 25,
         height = 25,
         transitionTime = 0,
         layerId = MapDat_df$poptext,
         chartdata = as.matrix(MapDat_df[, c("%Coral", "%NonCoral")]),
         colorPalette = c("red", "gray"),
         opacity = .85)
     } else {
       if(input$sel_MapMetric == "BleachRC") {
        chartmap <- basemap %>%
          addMinicharts(
            lng = MapDat_df$medLong,
            lat = MapDat_df$medLat,
            type = "pie",
            width = 2*MapDat_df$`%Coral`,
            transitionTime = 0,
            layerId = MapDat_df$poptext,
            chartdata = as.matrix(MapDat_df[, c("NoData", "UNBL", "BL1", "BL2", "BL3", "BL4")]),
            colorPalette = c("#FFFF00", "#404040", "#737373", "#8C8C8C", "#BFBFBF", "#EBEBEB"),
            opacity = .85
          )
      }
     }
  
  chartmap %>% fitBounds(minLong, minLat, maxLong, maxLat)
  }
  })
leafletOutput('coralmap', height=600)
```