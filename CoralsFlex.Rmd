---
title: "SFCN Coral Reefs"
output:
  flexdashboard::flex_dashboard:
    vertical_layout: scroll
    orientation: columns
    theme: sandstone   # theme options: default, cosmo, bootstrap, cerulean, journal, flatly, readable, spacelab, united, lumen, paper, sandstone, simplex, yeti
    css: custom_styles.css
runtime: shiny
---

```{r global, include=FALSE}

rm(list=ls())

### Load libraries -----
# Will automatically install any packages it can't find

pkgList <- c("flexdashboard", "shiny", "knitr", "gridExtra", "cowplot", "shinyWidgets", "leaflet", "plotly", "DT", "rtf", "lubridate", "leaflet.minicharts", "tidyverse", "magrittr", "htmlwidgets", "RSQLite", "multidplyr", "Rcpp", "scales", "patchwork", "zoo", "plyr")
inst <- pkgList %in% installed.packages()
if (length(pkgList[!inst]) > 0) {install.packages(pkgList[!inst],dep=TRUE)}
lapply(pkgList, library, character.only = TRUE)

options(shiny.maxRequestSize = 20*1024^2) # allows data files up to 20 MB to be imported
source("Corals.R")

rv <- reactiveValues(raw_dat = NULL, map_dat = NULL, groups_df = NULL, warn_list = NULL, transect_counts_df = NULL, cover_CIs_df = NULL, bleach_CIs_df = NULL, disease_df = NULL, colcounts_df = NULL)

rv_param_temp <- reactiveValues(cover_subdat = NULL, avail_sublevs = NULL, sel_showRSS = NULL, sel_bleach_showRSS = NULL, sel_lev = NULL, sel_sublev = NULL, avail_diseases = NULL, transects_subdat = NULL, transect_plot = NULL, transect_table = NULL, sel_raw_dates = NULL, bleach_subdat = NULL, disease_RSS = NULL, disease_transect = NULL, sel_disease_showRSS = NULL, cover_plot = NULL, relcover_plot = NULL, bleach_pc_plot = NULL, bleach_rc_plot = NULL, lesion_RSS = NULL, lesion_transect = NULL)

tags$style("table {
           height: calc(100vh - 80px) !important;
           }")

```

```{r functions}

FuncWarnTable <-function(colnam) {
  validate(need(!is.null(rv$warn_list), message = FALSE))
  x_tab <- rv$warn_list[[colnam]]
  validate(need(nrow(x_tab) > 0, "No warnings to show"))
  return(x_tab)
}

FuncPlotPointCI <- function(dat, denom, sel_error, sel_splitplot, free_ymax, set_ymax, y_text, title_text, which_showRSS, PC_blackwhite) {
  # Function to generate point plots with error bars
  #
  # Args:
  #   CI_dat:  The CI data frame
  #   denom: "TransectCount" for % cover or "CategoryCount" for relative cover
  #
  # Returns:
  #   List of point plots with error bars
  # 
  
  # Colorblind-friendly palette
  cbp1 <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7", "#0072B2", "#D55E00", "#999999", "#F0E442", "#000000", "chocolate4", "purple4", "chartreuse", "lightpink", "honeydew2") 
  
  # Set up the data
  plot_dat <- dat %>%
    dplyr::filter(DenomGroup == denom) %>% 
    dplyr::rename(
      CI_low = contains(paste0(sel_error, "_low")),
      CI_high = contains(paste0(sel_error, "_high")))
  
  # assign colors
    color_levels <- switch((sel_splitplot == "one_loc_many_sub")+1,  sort(unique(plot_dat$RSS)), sort(unique(plot_dat$NumerLevel))) # levels to be assigned colors
    cbp1_assigned <- switch((length(color_levels) <= length(cbp1)) + 1,  colorRampPalette(cbp1)(length(color_levels)), cbp1[1:length(color_levels)])
   
    p <- 
      ggplot(data = plot_dat, aes_string(x = "SurvDate", y = "EstimCov", colour = if_else(sel_splitplot == "one_loc_many_sub", "NumerLevel", "RSS"))) 
    
    if(PC_blackwhite) {
      p <- p + scale_colour_grey(guide = guide_legend(override.aes = list(size=1)))
    } else {
      p <- p +
        scale_color_manual(values = cbp1_assigned, guide = guide_legend(override.aes = list(size=1)))
    }
  
  p <- p +
    geom_point(aes(text = paste0("Group Level: ", NumerLevel, "<br>Reporting Site: ", ReportingSite, "<br>Site: ", Site, "<br>Survey Date: ", SurvDate, "<br># of Transects: ", N, "<br>% Cover: ", EstimCov, "<br>Lower CI: ", CI_low, "<br>Upper CI: ", CI_high))) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works
    geom_line(aes(text = paste0("Group Level: ", NumerLevel, "<br>Reporting Site: ", ReportingSite, "<br>Site: ", Site, "<br>Survey Date: ", SurvDate, "<br># of Transects: ", N, "<br>% Cover: ", EstimCov, "<br>Lower CI: ", CI_low, "<br>Upper CI: ", CI_high)), group = if_else(sel_splitplot == "one_loc_many_sub", "NumerLevel", "RSS")) + # need to add this grouping to geom_line, otherwise the text will cause it to group incorrectly. Need to add text b/c otherwise the line will not show when plotly tooltip is set to "text"
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = .25)
  
  facet_vars <- switch(sel_splitplot,
                       "one_loc_many_sub" = "~ RSS",
                       "one_sub_many_loc" = "~ NumerLevel")
  
  if(free_ymax == FALSE & !is.null(set_ymax)) {
    p <- p + ylim(0, set_ymax)
  } else {
    p <- p +
    expand_limits(y = c(0, 1)) # y-axes must include 1
  }
  
  p <- p +
    labs(title = title_text, x = "Year", y = y_text) +
    scale_x_date(date_labels = "%Y", breaks = scales::pretty_breaks()) +
    facet_wrap(as.formula(facet_vars), scales = if_else(free_ymax, "free_y", "fixed"), ncol = 1) +
    theme_bw(base_size = 12)
  # +
  #   theme(legend.text = element_text(size = 12),
  #         legend.title = element_text(size = 12))
      
  facet_ht <- 250 # 215
  add_on_ht <- 150 # 150, this is for x-axis
  num_locs <- length(rv_param_temp$sel_showRSS)
  num_sub <- length(rv_param_temp$sel_sublev)
   
  page_ht <- switch(sel_splitplot,
                    "one_loc_many_sub" = num_locs * facet_ht + add_on_ht,
                    "one_sub_many_loc" = num_sub * facet_ht + add_on_ht)

  gp <- ggplotly(p,
                 tooltip = "text", # make sure only the custom text is shown on hover
                 height = page_ht) # specify the total plot height here because this layout will be applied to the entire page
  
  gp <- gp %>%
    # add_annotations( # y-axis title
    #   text = "TEST-Y-ANNOT",
    #   x = -0.04,
    #   y = 0.5,
    #   yref = "paper",
    #   xref = "paper",
    #   xanchor = "right",
    #   yanchor = "middle",
    #   textangle = -90,
    #   showarrow = FALSE,
    #   font = list(size = 16)
    # ) %>%
    # add_annotations( # x-axis title
    #   text = "TEST-X-ANNOT",
    #   x = 0.5,
    #   y = -0.15,
    #   yref = "paper",
    #   xref = "paper",
    #   xanchor = "middle",
    #   yanchor = "top",
    #   textangle = 0,
    #   showarrow = FALSE,
    #   font = list(size = 16)
    # ) %>%
  layout(
    margin = list(
      t=80,
      b=90,
      l= 100,
      r=15))
  
  gp[['x']][['layout']][['annotations']][[2]][['x']] <- -0.12 # move y-axis title more to the left
  gp[['x']][['layout']][['annotations']][[1]][['y']] <- -0.03 # move x-axis title down more. This affects the x-axis title specified in ggplot
  
  return(gp)
}

FuncPlotPointDisease <- function(dat, metric, free_ymax, set_ymax, y_text, disease_by_transect) {
  # Function to generate point plots for disease counts and prevalence
  #
  # Args:
  #   dat:  The disease data frame (either site- or transect-level prevalence)
  #
  # Returns:
  #   List of point plots
  # 
  
  # Colorblind-friendly palette

  plot_dat <- dat %>%
    dplyr::mutate(PlotMetric = get(metric))
  
  if(disease_by_transect == TRUE){ # if separate line for each transect...
    p <- 
      ggplot(data = plot_dat, aes(x = SurvDate, y = PlotMetric, colour = Site_Transect)) +
      scale_color_viridis_d(name = metric, direction=-1, guide = guide_legend(override.aes = list(size=1.25))) +
      geom_point(aes(text = paste0("Reporting Site: ", ReportingSite, "<br>Site: ", Site, "<br>Survey Date: ", SurvDate, "<br>Transect: ", Transect, "<br>Y-VALUE: ", PlotMetric, "<br><br>Number of Diseased Colonies: ", TransectDiseased, "<br>Stony Coral Count 1: ", StonyCoralCount1, "<br> Stony Coral Count 2: ", StonyCoralCount2, "<br>DIFF Stony Coral Count: ", StonyCoralCountDIFF, "<br>Avg Stony Coral Count: ", StonyCoralCountAVG, "<br>Disease Prevalence: ", TransectPrev))) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works
    geom_line(aes(text = paste0("Reporting Site: ", ReportingSite, "<br>Site: ", Site, "<br>Survey Date: ", SurvDate, "<br>Transect: ", Transect, "<br>Y-VALUE: ", PlotMetric, "<br><br>Number of Diseased Colonies: ", TransectDiseased, "<br>Stony Coral Count 1: ", StonyCoralCount1, "<br> Stony Coral Count 2: ", StonyCoralCount2, "<br>DIFF Stony Coral Count: ", StonyCoralCountDIFF, "<br>Avg Stony Coral Count: ", StonyCoralCountAVG, "<br>Disease Prevalence: ", TransectPrev)), group = "Transect") # need to add this grouping to geom_line, otherwise the text will cause it to group incorrectly. Need to add text b/c otherwise the line will not show when plotly tooltip is set to "text"
  } else {
    p <- 
      ggplot(data = plot_dat, aes(x = SurvDate, y = PlotMetric)) +
      geom_point(aes(text = paste0("Reporting Site/Site: ", RSS, "<br>Survey Date: ", SurvDate, "<br>Y-VALUE: ", PlotMetric, "<br><br>Number of Diseased Colonies: ", SiteDiseased, "<br>Avg Number of Colonies: ", SiteStonyCoralCountAVG, "<br>Disease Prevalence: ", SitePrev))) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works
      geom_line(aes(text = paste0("Reporting Site/Site: ", RSS, "<br>Survey Date: ", SurvDate, "<br>Y-VALUE: ", PlotMetric, "<br><br>Number of Diseased Colonies: ", SiteDiseased, "<br>Avg Number of Colonies: ", SiteStonyCoralCountAVG, "<br>Disease Prevalence: ", SitePrev)), group = "RSS")
    
  }
  
   if(free_ymax == FALSE & !is.null(set_ymax)) {
    p <- p + ylim(0, set_ymax)
  } else {
    p <- p +
    expand_limits(y = c(0, 0)) # y-axes must include 0
  }
  
  p <- p +
    labs(x = "Year", y = y_text) +
    scale_x_date(date_labels = "%Y", breaks = scales::pretty_breaks()) +
    facet_wrap(~RSS, scales = if_else(free_ymax, "free_y", "fixed"), ncol = 1) +
    theme_bw(base_size = 12)
  
  if(disease_by_transect == TRUE) {
    p <- p + 
      theme(legend.position = "top",
            legend.text = element_text(size = 16),
            legend.title = element_text(size = 16)
      )
    disease_legend <- ggpubr::as_ggplot(cowplot::get_legend(p))
            
  } else {
    disease_legend <- NA
  }
  
  facet_ht <- 250 # 215
  add_on_ht <- 150 # 150, this is for x-axis

   
  page_ht <- length(unique(plot_dat$RSS)) * facet_ht + add_on_ht

  gp <- ggplotly(p,
                 tooltip = "text", # make sure only the custom text is shown on hover
                 height = page_ht) # specify the total plot height here because this layout will be applied to the entire page
  
  gp <- gp %>% layout(
    margin = list(
      t=80,
      b=70,
      l= 100,
      r=15))
  
  gp[['x']][['layout']][['annotations']][[2]][['x']] <- -0.12 # move y-axis title more to the left
  gp[['x']][['layout']][['annotations']][[1]][['y']] <- -0.02 # move x-axis title down more. This affects the x-axis title specified in ggplot
  
  return_list <- list(plot = gp, legend = disease_legend)
  
  return(return_list)
}

FuncPlotPointLesion <- function(dat, metric, free_ymax, set_ymax, y_text, disease_by_transect) {
  # Function to generate point plots for disease counts and prevalence
  #
  # Args:
  #   dat:  The disease data frame (either site- or transect-level prevalence)
  #
  # Returns:
  #   List of point plots
  # 
  
  # Colorblind-friendly palette

  plot_dat <- dat %>%
    dplyr::mutate(PlotMetric = get(metric))
  
  if(disease_by_transect == TRUE){ # if separate line for each transect...
    p <- 
      ggplot(data = plot_dat, aes(x = SurvDate, y = PlotMetric, colour = Site_Transect)) +
      scale_color_viridis_d(name = metric, direction=-1, guide = guide_legend(override.aes = list(size=1.25))) +
      geom_point(aes(text = paste0("Reporting Site: ", ReportingSite, "<br>Site: ", Site, "<br>Survey Date: ", SurvDate, "<br>Transect: ", Site_Transect, "<br>Y-VALUE: ", PlotMetric, "<br><br>Number of Disease Lesions: ", TransectLesionCounts, "<br>Summed Lesion Area: ", TransectLesionArea))) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works
    geom_line(aes(text = paste0("Reporting Site: ", ReportingSite, "<br>Site: ", Site, "<br>Survey Date: ", SurvDate, "<br>Transect: ", Site_Transect, "<br>Y-VALUE: ", PlotMetric, "<br><br>Number of Disease Lesions: ", TransectLesionCounts, "<br>Summed Lesion Area: ", TransectLesionArea)), group = "Site_Transect") # need to add this grouping to geom_line, otherwise the text will cause it to group incorrectly. Need to add text b/c otherwise the line will not show when plotly tooltip is set to "text"
  } else {
    p <- 
      ggplot(data = plot_dat, aes(x = SurvDate, y = PlotMetric)) +
      geom_point(aes(text = paste0("Reporting Site/Site: ", RSS, "<br>Survey Date: ", SurvDate, "<br>Y-VALUE: ", PlotMetric, "<br><br>Number of Disease Lesions: ", SiteLesionCounts, "<br>Summed Lesion Area: ", SiteLesionArea))) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works
      geom_line(aes(text = paste0("Reporting Site/Site: ", RSS, "<br>Survey Date: ", SurvDate, "<br>Y-VALUE: ", PlotMetric, "<br><br>Number of Disease Lesions: ", SiteLesionCounts, "<br>Summed Lesion Area: ", SiteLesionArea)), group = "RSS")
    
  }
  
   if(free_ymax == FALSE & !is.null(set_ymax)) {
    p <- p + ylim(0, set_ymax)
  } else {
    p <- p +
    expand_limits(y = c(0, 0)) # y-axes must include 0
  }
  
  p <- p +
    labs(x = "Year", y = y_text) +
    scale_x_date(date_labels = "%Y", breaks = scales::pretty_breaks()) +
    facet_wrap(~RSS, scales = if_else(free_ymax, "free_y", "fixed"), ncol = 1) +
    theme_bw(base_size = 12)
  
  if(disease_by_transect == TRUE) {
    p <- p + 
      theme(legend.position = "top",
            legend.text = element_text(size = 16),
            legend.title = element_text(size = 16)
      )
    disease_legend <- ggpubr::as_ggplot(cowplot::get_legend(p))
            
  } else {
    disease_legend <- NA
  }
  
  facet_ht <- 250 # 215
  add_on_ht <- 150 # 150, this is for x-axis

   
  page_ht <- length(unique(plot_dat$RSS)) * facet_ht + add_on_ht

  gp <- ggplotly(p,
                 tooltip = "text", # make sure only the custom text is shown on hover
                 height = page_ht) # specify the total plot height here because this layout will be applied to the entire page
  
  gp <- gp %>% layout(
    margin = list(
      t=80,
      b=70,
      l= 100,
      r=15))
  
  gp[['x']][['layout']][['annotations']][[2]][['x']] <- -0.12 # move y-axis title more to the left
  gp[['x']][['layout']][['annotations']][[1]][['y']] <- -0.02 # move x-axis title down more. This affects the x-axis title specified in ggplot
  
  return_list <- list(plot = gp, legend = disease_legend)
  
  return(return_list)
}

FuncPlotBleach <- function(dat, yaxis_title, free_ymax) {
  # Function to stacked bar plots of site totals
  #
  # Args:
  #   dat:  The bleach data frame
  #
  # Returns:
  #   Stacked bar plots
  # 
  if(free_ymax == FALSE) { # If one y-max for all plots, calculate what that should be
    ymax_bleach <- dat %>% select(RSS, SurvDate, EstimCov) %>% dplyr::group_by(RSS, SurvDate) %>% dplyr::mutate(TotCov = sum(EstimCov)) %>% pull(TotCov) %>% max(., na.rm = TRUE) %>% plyr::round_any(., 2.5, f = ceiling)
  } else {
      ymax_bleach <- NA
    }
  
  # yr_levels = min(dat$Year, na.rm = TRUE):max(dat$Year, na.rm = TRUE)
  plot_dat <- dat %>%
    dplyr::mutate(SurvDate = as.factor(SurvDate),
                  Year = as.factor(Year))
  
  ylab_list <- subtitle_list <- plots_list <- list()
 
  for(i in sort(unique(plot_dat$RSS))) {
    plot_num <- which(sort(unique(plot_dat$RSS))==i)
    
    sub_dat <- subset(plot_dat, RSS == i)
    yr_labels = paste0("  ", levels(sub_dat$Year), "  ")
    names(yr_labels) <- levels(sub_dat$Year)

    subtitle_list[[plot_num]] = list(
      text = paste0("Site: ", i), 
      x = 0.5,
      xanchor = "middle",
      xref = "paper",
      y = 0,
      yanchor = "top",
      yref=paste0("y", plot_num),
      showarrow = FALSE, 
      font=list(size=18))
    
    ylab_list[[plot_num]] = list(
      text = yaxis_title, 
      # align = "left", 
      valign = "center",
      x = -0.065,
      xanchor = "bottom",
      xref = "paper",
      # y = ifelse(free_ymax == FALSE, ymax_bleach/2, max(sub_dat$EstimCov, na.rm = TRUE)/2),
      yanchor = "middle",
      yref=paste0("y", plot_num),
      showarrow = FALSE, 
      textangle = -90,
      font=list(size=17))
    
    p <- ggplot(sub_dat, aes(x = SurvDate, y = EstimCov, fill = NumerLevel)) +
    geom_col(colour="black", size = 0.1, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(name = NULL, values = c("NoData" = "orange", "UNBL" = "gray25", "BL1" = "gray45", "BL2" = "gray55", "BL3" = "gray75", "BL4" = "gray92")) +
    # scale_y_continuous(expand = c(0, 0)) +
    labs(title = "   ", y = "", x = "")
    
      if(free_ymax == FALSE) {
    p <- p + ylim(0, ymax_bleach)
      }
    
    plots_list[[i]] <- p + theme_bw(base_size = 14) +
    facet_grid(.~Year, scales = "free_x", drop = FALSE, switch = "x") +
    theme(legend.text = element_text(size = 12),
          legend.title = element_text(size = 12),
          plot.subtitle = element_text(size = 18),
          axis.text.x=element_blank(), # this is the survey date, not  the year
          # axis.title.x=element_blank(),
          axis.ticks.x = element_blank(),
          # axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
          strip.text.x = element_text(size = 11, angle = 90),
          strip.background=element_blank(),
          panel.border = element_blank(),
          # panel.grid = element_blank(),
          panel.spacing = unit(0.05, "lines"))
}
  
  plotly_out <-
     plotly::subplot( # this automatically converts to plotly
      plots_list, # if I convert each with ggplotly() before subplot(), will mess up axes and not allow multiple bars per year
      nrows = length(plots_list),
      shareX = FALSE, # if set to FALSE, x-axis labels will overlap subplot title
      shareY = FALSE,
      titleX = TRUE,
      titleY = TRUE,
      which_layout = 1,
      margin = c(0.01, 0.01, 0.15, 0.05) # left, right, top, bottom--this is margin around each SUBPLOT
    ) %>%
      layout(
          margin = list(
          t=100,
          b=15,
          l= 80,
          r=40), 
          height = length(plots_list) * 350 + 150
          ) %>% # height here is deprecated, but having trouble getting reactive value in plotlyOutput
    layout( # put legend at top of first plot
      legend = list(
        orientation = "h",
        xanchor = "center",
        x = 0.5,
        yanchor = "bottom",
        y = 1.15)) %>%
  layout(
    title = list(
      text = paste0("Coral Bleaching as % Cover of Surveyed Site", "<br>", "<sup>", "Survey years are shown across top of each subplot; site name below each subplot", "</sup>"),
      yref = "page",
      yanchor = "bottom",
      automargin = TRUE),
    annotations = c(subtitle_list, ylab_list))
  
  # Get rid of duplicate legends
  for (i in seq_along(plotly_out$x$data)) {
    
  # Is the layer the first entry of the group?
  is_first <- plotly_out$x$data[[i]]$yaxis == "y"

  if (!is_first) plotly_out$x$data[[i]]$showlegend <- FALSE
  }
    return(plotly_out)
}

FuncPlotDisease <- function(dat, y_col, yaxis_title) {
  # NOT interactive because with interactive subplots of facet plots, the y-axis was not showing in the correct location 
  # Function to stacked bar plots of site totals
  #
  # Args:
  #   dat:  The bleach data frame
  #
  # Returns:
  #   Stacked bar plots
  # 
  
  # yr_levels = min(dat$Year, na.rm = TRUE):max(dat$Year, na.rm = TRUE)
  plot_dat <- dat %>%
    dplyr::mutate(SurvDate = as.factor(SurvDate),
                  Year = as.factor(Year))
  
  plots_list <- lapply(sort(unique(dat$RSS)), function(i) {
    
    ggplot(subset(plot_dat, RSS == i), aes_string(x = "SurvDate", y = y_col, fill = "DiseaseStatus")) +
      geom_col(colour="black", size = 0.1, position = position_stack(reverse = TRUE)) +
      scale_fill_manual(values = c("Diseased" = "red", "NotDiseased" = "black"), guide = "none") +
    scale_y_continuous(expand = c(0, 0)) +
    labs(title = " ", subtitle = paste0("Coral Disease at Site:  ", i), y = yaxis_title) +
    theme_bw(base_size = 14) +
    facet_grid(. ~ Year, scales = "free_x", drop = FALSE, switch = "x") +
    theme(legend.position = "none",
          plot.subtitle = element_text(size = 18),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
          strip.text.x = element_text(size = 11, angle = 90),
          strip.background=element_blank(),
          panel.border = element_blank(),
          panel.grid = element_blank(),
          panel.spacing = unit(-0.05, "lines"))
    })
  
  plots_page <- patchwork::wrap_plots(plots_list, ncol = 1)
  
  return(plots_page)
}
```

```{r action_button_import_new_data}
observeEvent(eventExpr = input$button_import, {
  if(is.null(input$filenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No coral data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$filenam$datapath), message = FALSE))
  
  if(is.null(input$sitesfilenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No sites data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$sitesfilenam$datapath), message = FALSE))
  
  if(is.null(input$diseasefilenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No disease data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$diseasefilenam$datapath), message = FALSE))
  
  if(is.null(input$colcountsfilenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No colony count data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$colcountsfilenam$datapath), message = FALSE))
  
  withProgress(message = "Please be patient. Calculating something wonderful...", value = 0, {
    FuncCorals(filenam = input$filenam$datapath, sitesfilenam = input$sitesfilenam$datapath, diseasefilenam = input$diseasefilenam$datapath, colcountsfilenam = input$colcountsfilenam$datapath, out_prefix = input$out_prefix)
    
    rv_param_temp <- reactiveValues(cover_subdat = NULL, avail_sublevs = NULL, sel_showRSS = NULL, sel_bleach_showRSS = NULL, sel_lev = NULL, sel_sublev = NULL, avail_diseases = NULL, transects_subdat = NULL, transect_plot = NULL, transect_table = NULL, sel_raw_dates = NULL, bleach_subdat = NULL, disease_RSS = NULL, disease_transect = NULL, sel_disease_showRSS = NULL, cover_plot = NULL, relcover_plot = NULL, bleach_plot = NULL, lesion_RSS = NULL, lesion_transect = NULL)
    
     showModal(modalDialog(
        title = "Done",
        paste0("A summary RDS file has been saved as '", input$out_prefix, ".RDS' in the current working directory, ", getwd(), ". You may now select it for viewing (use the input box below, titled 'Select a summary RDS file')")
      ))
    })
})
```

```{r action_load_RDS}
observeEvent(eventExpr = input$summaryfile, {
 
  tryCatch(out <- readRDS(input$summaryfile$datapath),
             error = function(e) {out_file <- NULL; print("Cannot import the selected file")})
  
  out <- readRDS(input$summaryfile$datapath)
  
  shiny::validate(need(all(names(out) %in% names(rv)), message = paste0("DATA PROCESSING ERROR: The loaded file needs to have these and only these list elements: ", paste(names(rv), collapse = ", "), ". Please try with another file.")))

  rv <- sapply(names(out), FUN = function(i) {rv[[i]] <- out[[i]]}, simplify = FALSE)
  
  rv_param_temp <- reactiveValues(cover_subdat = NULL, avail_sublevs = NULL, sel_showRSS = NULL, sel_bleach_showRSS = NULL, sel_lev = NULL, sel_sublev = NULL, avail_diseases = NULL, transects_subdat = NULL, transect_plot = NULL, transect_table = NULL, sel_raw_dates = NULL, bleach_subdat = NULL, disease_RSS = NULL, disease_transect = NULL, sel_disease_showRSS = NULL, cover_plot = NULL, relcover_plot = NULL, bleach_plot = NULL, lesion_RSS = NULL, lesion_transect = NULL)

  Sys.sleep(0.6)
 
  showModal(modalDialog(
  title = "Done",
  "You may now navigate to the other tabs for summary graphs and tables"
  ))
})
```

```{r action_buttons_select_sublevels}
observeEvent(eventExpr = input$sublev_all_button, {
  shiny::req(!is.null(rv_param_temp$avail_sublevs))
  updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$avail_sublevs, selected = rv_param_temp$avail_sublevs)
  })

observeEvent(eventExpr = input$sublev_none_button, {
  shiny::req(!is.null(rv_param_temp$avail_sublevs))
  updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$avail_sublevs, selected = character(0))
  })

observeEvent(eventExpr = input$sublev_esa_button, {
  shiny::req(!is.null(rv_param_temp$avail_sublevs), !is.null(input$sel_lev))
  if(input$sel_lev == "Taxon") {
    updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$avail_sublevs, selected = intersect(c("ACER", "APAL", "DCYL", "OANN", "OFAV", "OFRA"), rv_param_temp$avail_sublevs)) # select all ESA taxa that are among the available sublevels
  } else { # The ESA button should only show when grouping level is 'Taxon', but including this 'else' just in case
    showModal(modalDialog(
      title = "ESA not available",
    "This option is only available when selected grouping level is 'Taxon'."
    ))
  }
  })
```

```{r action_button_update_transect_cover}
# Action to update transect-level cover summaries with current user inputs
observeEvent(eventExpr = input$button_update_transect_cover, {
  shiny::req(!is.null(input$sel_raw_sitescale), !is.null(input$sel_raw_showRSS), !is.null(input$sel_raw_categ), !is.null(input$sel_raw_episodic), !is.null(rv$transect_counts_df))
  
  rv_param_temp$sel_raw_dates <- rv_param_temp$transects_subdat <- NULL
  rv_param_temp$transects_subdat <- rv$raw_dat %>%
    dplyr::select(-Subcategory, -FunctionalGroup, -Taxon, -BleachingCode, -CountOfTaxon) %>%
    dplyr::mutate(RSS = get(input$sel_raw_sitescale),
                  Site_Transect = paste(Site, Transect, sep = "_")) %>%
    dplyr::filter(
      RSS == input$sel_raw_showRSS,
      Category == input$sel_raw_categ,
      if(input$sel_raw_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
    dplyr::distinct() %>%
    dplyr::left_join(rv$transect_counts_df, by = c("TransectSurveyID", "Category")) %>%
    dplyr::mutate(Transect = factor(Transect))
  
  rv_param_temp$sel_raw_dates <- input$sel_raw_dates
})
```

```{r action_button_update_cover}
# Action to update cover summaries with current user inputs
observeEvent(eventExpr = input$button_update_cover, {

  shiny::req(!is.null(rv$cover_CIs_df), !is.null(input$sel_lev), !is.null(input$sel_sitescale), !is.null(input$sel_showRSS), !is.null(input$sel_episodic), !is.null(input$PC_blackwhite), !is.null(input$sel_error), !is.null(input$sel_splitplot))
  
  if(input$sel_lev != "Category") {shiny::validate(need(!is.null(input$sel_sublev), message = "Please select at least one sublevel, then press the green 'UPDATE COVER SUMMARIES' button"))}
 
  rv_param_temp$cover_plot <- NULL
  
  cover_subdat <- rv$cover_CIs_df %>%
    dplyr::filter(
      RSS %in% input$sel_showRSS,
      NumerGroup == input$sel_lev,
      NumerLevel %in% input$sel_sublev
      )
 
  if(input$sel_episodic == FALSE) { # remove episodic data
    cover_subdat %<>% filter(Purpose == "Annual") %>%
    dplyr::arrange(RSS, NumerLevel, SurvDate)}
  
  rv_param_temp$cover_subdat <- cover_subdat
  rv_param_temp$sel_showRSS <- input$sel_showRSS # make sure user selection doesn't automatically update plot page height
  rv_param_temp$sel_lev <- input$sel_lev
  rv_param_temp$sel_sublev <- input$sel_sublev

  Sys.sleep(0.75)
})
```

```{r action_button_update_bleach}
# Action to update bleach summaries with current user inputs
observeEvent(eventExpr = input$button_update_bleach, {

  shiny::req(!is.null(rv$bleach_CIs_df), !is.null(input$sel_bleach_sitescale), !is.null(input$sel_bleach_showRSS), !is.null(input$sel_bleach_episodic))
  
  rv_param_temp$sel_bleach_showRSS <- rv_param_temp$bleach_pc_plot <- rv_param_temp$bleach_rc_plot <- NULL
  
  rv_param_temp$bleach_subdat <- rv$bleach_CIs_df %>%
    dplyr::filter(
      RSS %in% input$sel_bleach_showRSS,
      if(input$sel_bleach_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
    dplyr::mutate(
      Year = lubridate::year(SurvDate), # for stacked bar plots
      NumerLevel = factor(NumerLevel, levels = c("NONCORAL", "NoData", "UNBL", "BL1", "BL2", "BL3", "BL4"))) %>%
    arrange(RSS, SurvDate, NumerLevel)
  
  rv_param_temp$sel_bleach_showRSS <- input$sel_bleach_showRSS # make sure user selection doesn't automatically update plot page height
  
  shiny::req(!is.null(input$bleach_RSS_active), !is.null(input$bleach_free_ymax), !is.null(rv_param_temp$bleach_subdat))
  
#   saveRDS(isolate(reactiveValuesToList(rv_param_temp)), paste0("temp_rv_param_temp.RDS"))
# saveRDS(isolate(reactiveValuesToList(input)), paste0("temp_input.RDS"))

  rv_param_temp$bleach_pc_plot <- FuncPlotBleach(dat = subset(rv_param_temp$bleach_subdat, DenomGroup == "TransectCount"), yaxis_title = "% Cover of Site", free_ymax = input$bleach_free_ymax)
  
  rv_param_temp$bleach_rc_plot <- FuncPlotBleach(dat = subset(rv_param_temp$bleach_subdat, DenomGroup == "CategoryCount"), yaxis_title = "% Cover of Corals", free_ymax = TRUE)
})
```

```{r action_buttons_select_diseases}
observeEvent(eventExpr = input$disease_all_button, {
  shiny::req(!is.null(rv_param_temp$avail_diseases))
  updateCheckboxGroupInput(session, "sel_diseases", label = "Select disease(s)", choices = rv_param_temp$avail_diseases, selected = rv_param_temp$avail_diseases)
  })

observeEvent(eventExpr = input$disease_none_button, {
  shiny::req(!is.null(rv_param_temp$avail_diseases))
  updateCheckboxGroupInput(session, "sel_diseases", label = "Select disease(s)", choices = rv_param_temp$avail_diseases, selected = character(0))
  })

observeEvent(eventExpr = input$disease_tissue_loss_button, {
  shiny::req(!is.null(rv_param_temp$avail_diseases))
    updateCheckboxGroupInput(session, "sel_diseases", label = "Select disease(s)", choices = rv_param_temp$avail_diseases, selected = intersect(c("BB", "SCTLD", "WB", "WPL", "WPX", "YB"), rv_param_temp$avail_diseases)) # select all tissue loss diseases that are among the available diseases. Also yellow-band, because that is measured as tissue loss disease
    })

observeEvent(eventExpr = input$disease_discoloration_button, {
  shiny::req(!is.null(rv_param_temp$avail_diseases))
    updateCheckboxGroupInput(session, "sel_diseases", label = "Select disease(s)", choices = rv_param_temp$avail_diseases, selected = intersect(c("DS"), rv_param_temp$avail_diseases)) # select all discoloration diseases that are among the available diseases
    })
``` 

```{r action_button_update_disease}
# Action to update disease summaries with current user inputs
observeEvent(eventExpr = input$button_update_disease, {
   # 
   
  shiny::req(!is.null(rv$disease_df), !is.null(rv$colcounts_df), !is.null(input$sel_disease_sitescale), !is.null(input$sel_disease_showRSS), !is.null(input$sel_disease_episodic), !is.null(input$sel_diseases))
  
  rv_param_temp$sel_disease_showRSS <- rv_param_temp$disease_RSS <- rv_param_temp$disease_transect <- rv_param_temp$lesion_RSS <- rv_param_temp$lesion_transect <- NULL

  # Subset of disease data to use
  diseases <- rv$disease_df %>%
    # dplyr::filter(DiseaseCertificationLevel == "Accepted") %>%
    dplyr::mutate(
      RSS = get(input$sel_disease_sitescale),
      Site_Transect = paste(Site, Transect, sep = "_"),
      DiseaseFull = paste0(DiseaseDescription, " (", DiseaseCode, ")"),
      TaxonFull = paste0(CoralScientificName, " (", Taxon, ")")) %>%
    dplyr::filter(
      RSS %in% input$sel_disease_showRSS,
      DiseaseCode %in% input$sel_diseases,
      if(input$sel_disease_episodic == FALSE) Purpose == "Annual" else TRUE)
  
  # Filter colony counts data for the user-specified RSS and calculate avg count
   master_counts <- rv$colcounts_df %>%
     # dplyr::filter(ColCountsCertificationLevel == "Accepted") %>%
     dplyr::mutate(RSS = get(input$sel_disease_sitescale)) %>%
     dplyr::filter(RSS %in% input$sel_disease_showRSS) %>%
     dplyr::mutate(Site_Transect = paste(Site, Transect, sep = "_"),
                   StonyCoralCountDIFF = abs(StonyCoralCount2 - StonyCoralCount1)) %>%
     dplyr::mutate(StonyCoralCountAVG = rowMeans(cbind(StonyCoralCount1, StonyCoralCount2), na.rm=T)) %>%
     dplyr::filter(!is.na(StonyCoralCountAVG))
   
   # Disease data with associated colony numbers. Can only calculate disease count and prevalence for the years where disease colony numbers recorded for all disease entries
   disease_cols_complete <- diseases %>%
     dplyr::select(TransectSurveyID, ColonyNumber, DiseaseFull, TaxonFull) %>%
     dplyr::filter(complete.cases(.))
   
   # Transect-level disease counts and prevalence, per survey event (to see the data by transect)
   disease_transect <- disease_cols_complete %>%
     dplyr::select(TransectSurveyID, ColonyNumber) %>%
     dplyr::distinct() %>%
     dplyr::group_by(TransectSurveyID) %>%
     dplyr::summarize(TransectDiseased = n_distinct(ColonyNumber)) %>%
     dplyr::right_join(master_counts, by = "TransectSurveyID") 
  
    disease_transect$TransectDiseased[is.na(disease_transect$TransectDiseased)]<- 0 # if there is a non-NA StonyCoralCountAVG, convert any NA disease count to zero
   disease_transect %<>%
     dplyr::mutate(
       Year = lubridate::year(SurvDate),
       TransectNotDiseased = StonyCoralCountAVG - TransectDiseased,
       TransectPrev = round(100* (TransectDiseased / StonyCoralCountAVG), 1)
       ) %>%
     ungroup()
   
   # RSS-level disease counts and prevalence (summed across transects for a survey event)
   disease_RSS <- disease_transect %>%
     dplyr::select(ParkCode, RSS, Year, SurvDate, Purpose, ProtocolVersion, ColCountsCertificationLevel, TransectDiseased, TransectNotDiseased, StonyCoralCountAVG) %>%
     dplyr::group_by(ParkCode, RSS, Year, SurvDate, Purpose, ProtocolVersion, ColCountsCertificationLevel) %>% # <<<<<<< NEED TO FIX THIS--BECAUSE SHOULD ONLY INCLUDE YEARS FOR WHICH ALL SITES ARE ACTIVE
     dplyr::summarize(
       SiteDiseased = sum(TransectDiseased),
       SiteNotDiseased = sum(TransectNotDiseased),
       SiteStonyCoralCountAVG = sum(StonyCoralCountAVG),
       SitePrev = round(100* (SiteDiseased / SiteStonyCoralCountAVG), 1), 
       ) %>%
     ungroup()
   
   # Lesion counts and area
   lesion_dat <- diseases %>%
     dplyr::filter(DiseaseCode != "DS" & !is.na(LesionLength) & !is.na(LesionWidth)) # some Dark Spot have lesion length and width entered but should not be considered a lesion disease
   if(nrow(lesion_dat) > 0) {
     lesion_transect <- lesion_dat %>%
       dplyr::mutate(LesionArea = LesionLength * LesionWidth) %>%
       dplyr::group_by(TransectSurveyID) %>%
       dplyr::mutate(
         TransectLesionCounts = n(),
         TransectLesionArea = sum(LesionArea)) %>%
       dplyr::select(ParkCode, ReportingSite, Site, IsActive, Site_Transect, SurvDate, TransectSurveyID, Purpose, ProtocolVersion, DiseaseCertificationLevel, RSS, TransectLesionCounts, TransectLesionArea) %>%
       dplyr::distinct()
     
     lesion_RSS <- lesion_transect %>%
     dplyr::select(ParkCode, RSS, SurvDate, Purpose, ProtocolVersion, DiseaseCertificationLevel, TransectLesionCounts, TransectLesionArea) %>%
     dplyr::group_by(ParkCode, RSS, SurvDate, Purpose, ProtocolVersion, DiseaseCertificationLevel) %>%
     dplyr::summarize(
       SiteLesionCounts = sum(TransectLesionCounts),
       SiteLesionArea = sum(TransectLesionArea)
     )
   } else {
       lesion_RSS <- lesion_transect <- NULL
     }
  
  
   rv_param_temp$sel_disease_showRSS <- input$sel_disease_showRSS
   rv_param_temp$disease_RSS <- disease_RSS
   rv_param_temp$disease_transect <- disease_transect
   rv_param_temp$lesion_RSS <- lesion_RSS
   rv_param_temp$lesion_transect <- lesion_transect

   })
```

Import
======================================

Column {data-width=10}
-------------------------------------

Column {data-width=525}
-------------------------------------
#### <font size="5"> Instructions for processing a raw data file (jump to Step 6 if you already have a summary RDS file)</font> 

<font size="4"> 

1.  Create a coral data CSV file that summarizes the coral data by transect with these required columns (case-sensitive): *BleachingCode, Category, CountOfTaxonCode, Date, FunctionalGroup, Latitude, Longitude, ParkCode, Purpose, Site, SubCategory, TaxonCode, Transect, TripName, Year*    

2.  Create a sites data CSV file that links reporting sites with sites and specifies if the sites are still active. The required colums are (case-sensitive): *ParkCode, Site, ReportingSite, ReportingSiteName, IsActive* (where "ReportingSiteName" is the full name corresponding with "ReportingSite", and "IsActive" = 1 for active sites and 0 for inactive sites)

3.  Enter a prefix to append to the output summary file.

4. Browse to and upload the coral and sites data files (CSV), then press the "Import and Process New Data" button.

5.  When data processing is completed, a summary data file will be output to the current working directory as an RDS with the name '(your prefix)_coralsummary.RDS'. PROCEED TO STEP #6 TO IMPORT THE NEWLY CREATED .RDS FILE.

</font> 

#### <font size="5"> Instructions for importing a summary RDS file</font> 

<font size="4"> 

6.  Browse to and import the '(your prefix)_coralsummary.RDS' file, to generate summaries in the plot and table tabs.

</font> 

#### <font size="5"> Using and exporting summary plots and tables </font> 

<font size="4"> 

* PLOTS: With all plots except stacked bar plots, hover over any point on the plot to see options (top right corner) for downloading plots as .png, zooming in/out, showing toggle spike lines, etc.

* TABLES: Click on a column name to sort records. Use the search box under a column name to filter records. Export buttons only export records visible on the current page. To export ALL data (or all filtered data), select 'Show [All] entries' to make all records visible on current page and then click the export button (e.g., Excel). For large data files, export may take a few seconds. 

</font> 

Column {data-width=10}
-------------------------------------

Column {data-width=225}
-------------------------------------

### PROCESS A RAW CORAL DATA FILE {data-height=200}
```{r select_raw_data}
textInput("out_prefix", label = "Prefix to append to output files: ", value = paste0("corals", gsub(pattern = "-", replacement = "", x = Sys.Date()), "_"), width = "100%")

fileInput("filenam", label = "Select a coral survey CSV file (make sure you've entered a file Prefix!)", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

fileInput("sitesfilenam", label = "Select a sites CSV file", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

fileInput("diseasefilenam", label = "Select a disease CSV file", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

fileInput("colcountsfilenam", label = "Select a colony counts CSV file", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

actionButton("button_import", "IMPORT AND PROCESS NEW DATA", width = "100%")
```

### IMPORT A CORAL SUMMARY FILE {data-height=100}
```{r select_files}
fileInput("summaryfile", label = "Select a summary RDS file", accept = c('.RDS'), width = "100%")
```

Data Warnings
====================================== 
Column
-------------------------------------
**PERCENT OF DATA CERTIFIED AS "ACCEPTED"**
*(All data are included regardless of certification level)*
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "CertLevel")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
``` 


**SURVEY TRIPS WITH PURPOSE OTHER THAN "ANNUAL" OR "EPISODIC"**
*(These data are excluded from analyses)*
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "AltPurp")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SURVEY TRIPS WITH BLEACHING CODES ASSIGNED TO NON-CORAL TRANSECT HITS**
*(These data are excluded from bleaching analyses)*
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "BleachCode")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SITE-SURVEYS WITH TRANSECT COUNTS OTHER THAN 4 OR 20**
```{r}
renderTable({
  validate(need(!is.null(rv$warn_list), message = FALSE))

  TransCount <- rv$warn_list$TransCount
  validate(need(nrow(TransCount) > 0, "No warnings to show"))
  TransCount$`Survey Date` <- as.character(lubridate::ymd(TransCount$`Survey Date`)) # renderTable does not play nice with dates--need to format as character
  TransCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH TOTAL TAXON COUNTS NOT DIVISIBLE BY 10**
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "TaxonCountDiv")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH TOTAL TAXON COUNTS LESS THAN 200 OR GREATER THAN 480**
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "TaxonCount")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH EQUIPMENT OR SHADOW HITS EXCEEDING 5% OF TOTAL TAXON COUNTS**
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "EquipShadowCount")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH UNKNOWN ("UNK") HITS EXCEEDING 5% OF TOTAL TAXON COUNTS**
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "UNKCount")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**DISEASE RECORDS WITH UNKNOWN DISEASE CODE**
*(These data are excluded from analyses)*
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "UNKDisease")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**DISEASE RECORDS FOR COLONIES < 4CM**
*(These data are excluded from analyses)*
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "DiseaseColLT4CM")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**DISEASE SITE-TRANSECT-SURVEY DATES WITHOUT MATCHING CORAL VIDEO RECORDS**
*(These data are still presented in disease summaries)*
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "UnmatchedDiseaseID")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**COLONY COUNTS SITE-TRANSECT-SURVEY DATES WITHOUT MATCHING CORAL VIDEO RECORDS**
*(These data are still presented in disease summaries, if corresponding disease data are available)*
```{r}
renderTable({
  shiny::req(!is.null(rv$warn_list))
  FuncWarnTable(colnam = "UnmatchedColCountsID")
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

% Cover per Transect
======================================  
Inputs {.sidebar data-width=300}
-------------------------------------
```{r input_raw_filter}
br()

h4("Data Filter Options")

wellPanel(
  id = "wp_raw_criteria",

  # Pre-filter data
  checkboxInput("raw_RSS_active", label = "Only use active sites", value = FALSE), #NOTE: Don't need switch() function to keep inputs from changing on these
  checkboxInput("sel_raw_episodic", label = "Include episodic survey data", value = TRUE),
  
  # Select spatial scale--sites or reporting sites
  renderUI({
    radioButtons("sel_raw_sitescale", 
             label = "Show data for this spatial scale:", 
             choiceNames = list("Reporting Site", "Site"),
             choiceValues = list("ReportingSite", "Site"),
             selected = switch(is.null(input$sel_raw_sitescale)+1, input$sel_raw_sitescale, "Site"))
    }),
  
  tags$div(renderText({
    shiny::req(!is.null(input$sel_raw_sitescale))
    if(input$sel_raw_sitescale == "ReportingSite") {
      paste0("NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites")  # Explain how reporting sites are summarized
      }
    }), style = "font-size:14px; color:red; font-weight:bold;"),

  renderUI({
    shiny::req(!is.null(rv$raw_dat), !is.null(input$sel_raw_sitescale), !is.null(input$raw_RSS_active))
    
    raw_RSS_choices <- rv$raw_dat %>%
      dplyr::filter(if(input$raw_RSS_active == TRUE) IsActive == 1 else TRUE) %>%
      {if(input$sel_raw_sitescale == "Site") dplyr::pull(., Site) else dplyr::pull(., ReportingSite)} %>% unique(.)
    
    shiny::req(!is.null(raw_RSS_choices))
    
    # Select (reporting) site
    selectInput("sel_raw_showRSS", 
                       label = paste0("Show results for this ", if_else(input$sel_raw_sitescale == "ReportingSite", "reporting site", "site")),
                       choices = raw_RSS_choices, 
                       selected = switch(is.null(input$sel_raw_showRSS)+1, input$sel_raw_showRSS, raw_RSS_choices[1]))
    }),

  renderUI({
    shiny::req(!is.null(rv$raw_dat))
    
    selectInput("sel_raw_categ",
                label = paste0("Show transect counts for this category"),
                choices = sort(unique(rv$raw_dat$Category)),
                selected = switch(is.null(input$sel_raw_categ)+1, input$sel_raw_categ, "CORAL"))
    }),
  
  renderUI({
    shiny::req(!is.null(rv$raw_dat), !is.null(input$sel_raw_sitescale), !is.null(input$sel_raw_showRSS), !is.null(input$sel_raw_categ), !is.null(input$sel_raw_episodic))

    date_opts <- rv$raw_dat %>%
      dplyr::mutate(RSS = get(input$sel_raw_sitescale)) %>%
      dplyr::filter(
        RSS == input$sel_raw_showRSS,
        Category == input$sel_raw_categ,
        if(input$sel_raw_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
      dplyr::pull(SurvDate) %>%
      as.character()
   
    sliderTextInput("sel_raw_dates",
                label = "Compare % cover for two survey events (red lines on plots)",
                choices = date_opts,
                selected = c(min(date_opts, na.rm = TRUE), max(date_opts, na.rm = TRUE))
    )
  }),
  
  br(),
  
  br(),
    
  actionButton("button_update_transect_cover", "UPDATE TRANSECT SUMMARIES", class = "green-action-button")

) # end of 'wp_raw_criteria'
```

% Cover per Transect
-------------------------------------
#### <font size="3">**These line graphs show % cover of the selected category (e.g., CORAL) in each transect of the selected site. The corresponding table shows % cover values for two user-selected survey dates (red vertical lines in line graphs).**</font>

* % cover is calculated from the survey data, without estimates of statistical error.

* In the table column "Change in %Cover", table cells are colored orange for negative values (decrease in % cover from first to second date) and blue for positive values (increase in % cover from first to second date).

<h3>% Cover per Transect for Selected Category and Site</h3>

###

```{r plot_transects}

output$out_transects_plotly <- plotly::renderPlotly({
  
  shiny::validate(need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(need(!is.null(rv_param_temp$transects_subdat), message = "Make selections from 'Data Filter Options' on the left, then press the green 'UPDATE TRANSECT SUMMARIES' button"))

  shiny::req(!is.null(rv$transect_counts_df), !is.null(rv_param_temp$sel_raw_dates))
 
  p <- ggplot(rv_param_temp$transects_subdat, aes(x = SurvDate, y = PercCov)) +
    labs(x = NULL, y = NULL, title = paste0("% Cover per Transect for ", toupper(unique(rv_param_temp$transects_subdat$Category)), " at ", unique(rv_param_temp$transects_subdat$RSS))) +
    scale_x_date(date_labels = "%Y", breaks = scales::pretty_breaks()) +
    geom_point() +
    geom_line() +
    geom_vline(xintercept = as.numeric(as.Date(rv_param_temp$sel_raw_dates)), color = "red") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    facet_wrap(vars(Site_Transect))
  
  rv_param_temp$transect_plot <- ggplotly(p) %>%
    add_annotations( # y-axis title
      text = "% Cover of Coral",
      x = -0.04,
      y = 0.5,
      yref = "paper",
      xref = "paper",
      xanchor = "right",
      yanchor = "middle",
      textangle = -90,
      showarrow = FALSE,
      font = list(size = 16)
    ) %>%
    add_annotations( # x-axis title
      text = "Year",
      x = 0.5,
      y = -0.15,
      yref = "paper",
      xref = "paper",
      xanchor = "middle",
      yanchor = "top",
      textangle = 0,
      showarrow = FALSE,
      font = list(size = 16)
    ) %>%
  layout(
    margin = list(l = 75, r = 75,
          b = 90, t = 75)
  )
  
  rv_param_temp$transect_plot
  })

tags$style("#out_transects_plotly{overflow-x:scroll;overflow-y:scroll}")
plotlyOutput("out_transects_plotly")
```

### 

```{r}
output$out_transects_tab <- DT::renderDT({
  
  shiny::req(!is.null(rv_param_temp$transects_subdat), !is.null(rv_param_temp$sel_raw_dates))
  shiny::req(length(unique(rv_param_temp$sel_raw_dates)) == 2)

  compare_dat <- rv_param_temp$transects_subdat %>%
    dplyr::select(ReportingSite, Site, Transect, SurvDate, PercCov) %>%
    dplyr::mutate(SurvDate = as.character(SurvDate)) %>%
    dplyr::filter(SurvDate %in% rv_param_temp$sel_raw_dates)  %>%
    tidyr::pivot_wider(names_from = SurvDate, values_from = PercCov, names_prefix = "%Cover on ")
  if(ncol(compare_dat) == 5){
    compare_dat$`Change in %Cover` = round(compare_dat[[5]] - compare_dat[[4]], 1)
  } else {
    compare_dat$`Change in %Cover` = NA
  }
  
  shiny::req(!is.null(compare_dat))
  num_incr <- sum(compare_dat$`Change in %Cover` > 0, na.rm = TRUE) 
  num_transects <- length(unique(compare_dat$Transect))
  perc_incr <- round(100*(num_incr/num_transects), 1)
  
  rv_param_temp$transect_table <- DT::datatable(
    compare_dat,
    filter = "top",
    class="compact stripe",
    caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: center; color:blue;',
    htmltools::h2(paste0(toupper(unique(rv_param_temp$transects_subdat$Category)), " increased at ", num_incr, " of ", num_transects, " transects (", perc_incr, "%) from ", zoo::as.yearmon(rv_param_temp$sel_raw_dates[[1]]), " to ", zoo::as.yearmon(rv_param_temp$sel_raw_dates[[2]])))),
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      pageLength = 20,
      scrollX = TRUE,
      autoWidth = TRUE,
      dom = 'Blrtip', # removed 'f', which is the global filter
      buttons = c('copy', 'csv', 'excel'),
      columnDefs = list(list(className = 'dt_center', targets = "_all"))
      )
  ) %>% formatStyle("Change in %Cover",
                    backgroundColor  = styleInterval(c(0), c("orange", "lightblue"))
  )
  
  rv_param_temp$transect_table
})

tags$style("#out_transects_tab{overflow-x:scroll;overflow-y:scroll}")
dataTableOutput("out_transects_tab")

```

% Cover and Relative Cover (line graphs w/error bars) {data-navmenu="Group Cover per Site"}
======================================  
Inputs {.sidebar data-width=300}
-------------------------------------
```{r input_cover_filter}
br()

h4("Data Filter Options")

wellPanel(
  id = "wp_cover_criteria",

  # Pre-filter data
  checkboxInput("RSS_active", label = "Only use active sites", value = FALSE), #NOTE: Don't need switch() function to keep inputs from changing on these
  checkboxInput("sel_episodic", label = "Include episodic survey data", value = TRUE),
  
  # Select spatial scale--sites or reporting sites
  renderUI({
    radioButtons("sel_sitescale", 
             label = "Summarize data at this spatial scale:", 
             choiceNames = list("Reporting Site", "Site"),
             choiceValues = list("ReportingSite", "Site"),
             selected = switch(is.null(input$sel_sitescale)+1, input$sel_sitescale, "Site"))
    }),
  
  tags$div(renderText({
    shiny::req(!is.null(input$sel_sitescale))
    if(input$sel_sitescale == "ReportingSite") {
      paste0("NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites")  # Explain how reporting sites are summarized
      }
    }), style = "font-size:14px; color:red; font-weight:bold;"),
  
  renderUI({
    shiny::req(!is.null(rv$cover_CIs_df), !is.null(input$sel_sitescale), !is.null(input$RSS_active))
    
    RSS_choices <- rv$cover_CIs_df %>%
      dplyr::filter(if(input$RSS_active == TRUE) IsActive == 1 else TRUE) %>%
      {if(input$sel_sitescale == "Site") dplyr::pull(., Site) else dplyr::pull(., ReportingSite)} %>% unique(.) %>% na.omit(.)

    # Select (reporting) sites
    checkboxGroupInput("sel_showRSS", 
                       label = paste0("Show results for these ", if_else(input$sel_sitescale == "ReportingSite", "reporting sites", "sites")),
                       choices = RSS_choices, 
                       selected = if(!is.null(input$sel_showRSS) & all(input$sel_showRSS %in% RSS_choices)) {input$sel_showRSS} else {RSS_choices}) # if selections already made and they are a subset of RSS_choices, then use those selections; otherwise, use RSS_choices as default
    }),
  
  # selected = if(!is.null(input$sel_showRSS) & all(input$sel_showRSS %in% RSS_choices)) {input$sel_showRSS} else {RSS_choices}
  # Select numerator grouping scale for cover estimates
  renderUI({
    selectInput("sel_lev", 
                label = "Select grouping level", 
                choices = c("Category" = "Category", "Functional Group" = "FunctionalGroup", "Taxon" = "Taxon"),
                selected = switch(is.null(input$sel_lev)+1, input$sel_lev, "Category"))
    }),
  
  # If grouping option is finer than Category, then user must select a category to see the selection options for the finer grouping level
  
  renderUI({ # if estimating cover for a level other than Category, restrict summaries to a single Category
    shiny::req(!is.null(rv$cover_CIs_df), !is.null(input$sel_lev), !is.null(input$sel_showRSS))
    shiny::req(input$sel_lev != "Category")

    avail_categ <- sort(unique(rv$cover_CIs_df$Category[rv$cover_CIs_df$NumerGroup==input$sel_lev & rv$cover_CIs_df$RSS %in% input$sel_showRSS]))
    
    selectInput("sel_categ",
                label = paste0("Show ", input$sel_lev, " for this category"),
                choices = avail_categ,
                selected = switch(is.null(input$sel_categ)+1, input$sel_categ, "CORAL"))
    }),
  
  # Group levels to choose from (e.g., algae, coral...) for the selected grouping level. For Functional Group, only options are ALGAE and CORAL. For Taxon, options are ALGAE, CORAL, GORGO, SPONGE
  renderUI({
    shiny::req(!is.null(rv$groups_df), !is.null(input$sel_lev), !is.null(input$sel_sitescale), !is.null(input$sel_showRSS), !is.null(input$sel_episodic))
    
    rv_param_temp$avail_sublevs <- rv$cover_CIs_df %>%
      dplyr::filter(
        RSS %in% input$sel_showRSS,
      NumerGroup == input$sel_lev) %>%
      dplyr::filter(if(input$sel_lev != "Category" & !is.null(input$sel_categ)) Category == input$sel_categ else TRUE) %>%
      dplyr::filter(if(input$sel_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
      pull(NumerLevel) %>%
      as.character() %>%
      unique() %>%
      na.omit(.) %>%
      sort()

  checkboxGroupInput("sel_sublev", 
                     label = "Select sublevel(s)",
                     choices = rv_param_temp$avail_sublevs, 
                     selected = if(!is.null(input$sel_sublev) & all(input$sel_sublev %in% rv_param_temp$avail_sublevs)) {input$sel_sublev} else {character(0)})
  }),
  
  actionButton("sublev_all_button", "Select All", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  actionButton("sublev_none_button", "Select None", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  conditionalPanel(
    condition = "input.sel_lev == 'Taxon'",
    actionButton("sublev_esa_button", "Select ESA", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px")
    ), 

  br(),
  
  br(),
    
  actionButton("button_update_cover", "UPDATE COVER SUMMARIES", class = "green-action-button")
) # end of 'wp_cover_criteria'
```
 
```{r input_cover_format}

h4("Figure Format Options (plots update immediately)")

renderUI({
  radioButtons("sel_error",
             label = "Bootstrapped error bars to plot",
             choiceNames = list("90%CI", "68%CI (~1SE)", "50%CI"),
             choiceValues = list("90%CI", "68%CI", "50%CI"),
             selected = switch(is.null(input$sel_error)+1, input$sel_error, "68%CI"))
})

renderUI({
  shiny::req(!is.null(input$sel_showRSS), !is.null(input$sel_sublev))

  selectInput("sel_splitplot", label = "In a single plot, show: ", choices = c("One sublevel, many locations" = "one_sub_many_loc", "One location, many sublevels" = "one_loc_many_sub"), selected = switch(is.null(input$sel_splitplot)+1, input$sel_splitplot, "one_sub_many_loc"), width = "95%")
})

renderUI({
  checkboxInput("PC_blackwhite", label = "Plot in grayscale (can only handle up to 6 categories)", value = switch(is.null(input$PC_blackwhite)+1, input$PC_blackwhite, FALSE))
})

checkboxInput("free_ymax", label = "Allow y-axes scales to vary among plots", value = TRUE)

renderUI({
  shiny::req(input$free_ymax == FALSE & !is.null(rv_param_temp$cover_subdat)) # this option is only shown when y-axes scales are not allowed to vary among plots
  top_val <-plyr::round_any(max(rv_param_temp$cover_subdat$`90%CI_high`[rv_param_temp$cover_subdat$DenomGroup == "TransectCount"], na.rm = TRUE), 5, f = ceiling)
  numericInput("set_PC_ymax", label = "Set y-axis maximum for % cover", min = 1, max = 105, step = 1, value = top_val)
})

tags$div(renderText({
    shiny::req(!is.null(input$set_PC_ymax), !is.null(input$free_ymax), !is.null(rv_param_temp$cover_subdat))
    if(input$free_ymax == FALSE & input$set_PC_ymax < max(rv_param_temp$cover_subdat$`90%CI_high`[rv_param_temp$cover_subdat$DenomGroup == "TransectCount"], na.rm = TRUE)) {
      paste0("Some data points may not show in % cover plots. Selected y-axis range does not span the full data.")  
      }
    }), style = "font-size:14px; color:red; font-weight:bold;")

renderUI({
  shiny::req(input$free_ymax == FALSE & input$sel_lev != "Category" & !is.null(rv_param_temp$cover_subdat)) # this option is only shown when y-axes scales are not allowed to vary among plots
  top_val <-plyr::round_any(max(rv_param_temp$cover_subdat$`90%CI_high`[rv_param_temp$cover_subdat$DenomGroup == "CategoryCount"], na.rm = TRUE), 5, f = ceiling)
  numericInput("set_RC_ymax", label = "Set y-axis maximum for relative cover", min = 1, max = 105, step = 1, value = top_val)
})

tags$div(renderText({
    shiny::req(!is.null(input$set_RC_ymax), !is.null(input$free_ymax), !is.null(rv_param_temp$cover_subdat))
    if(input$free_ymax == FALSE & input$set_RC_ymax < max(rv_param_temp$cover_subdat$`90%CI_high`[rv_param_temp$cover_subdat$DenomGroup == "CategoryCount"], na.rm = TRUE)) {
      paste0("Some data points may not show in relative cover plots. Selected y-axis range does not span the full data.")  
      }
    }), style = "font-size:14px; color:red; font-weight:bold;")


```

% Cover and Relative Cover per Site
-------------------------------------
#### <font size="3">**These line graphs show mean transect % cover (left-side panel) and relative % cover (right-side panel) for each selected site and category/functional group/taxon level**</font>

* Relative % cover is calculated relative to the category (e.g., CORAL)

* Confidence intervals are bootstrapped. For a NORMALLY distributed characteristic, the 68% CI is equal to the mean cover estimate +/- 1 standard error.

####
<div class="flex-container">
  <div class="flex-left">

```{r plot_PC}
output$out_cover_plotly <- plotly::renderPlotly({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(
    need(!is.null(rv_param_temp$cover_subdat), message = "From 'Data Filter Options' on the left, please select a grouping level and sublevel(s), then press the green 'UPDATE COVER SUMMARIES' button"))
  
  shiny::req(!is.null(input$sel_splitplot), !is.null(input$PC_blackwhite), !is.null(input$sel_error), !is.null(rv_param_temp$sel_showRSS), !is.null(rv_param_temp$sel_sublev), !is.null(input$free_ymax))

rv_param_temp$cover_plot <- FuncPlotPointCI(dat = rv_param_temp$cover_subdat, denom = "TransectCount", sel_error = input$sel_error, sel_splitplot = input$sel_splitplot, free_ymax = input$free_ymax, set_ymax = input$set_PC_ymax, y_text = paste0("Mean % Cover (", input$sel_error, ")"), title_text = "% Cover per Site",which_showRSS = "cover", PC_blackwhite = input$PC_blackwhite)

rv_param_temp$cover_plot 
# %>% layout(legend = list(orientation = 'h', xanchor = "left", yanchor = "bottom", y = 1.2, x = 0))


})

plotlyOutput("out_cover_plotly")
```

</div>
<div class="flex-right">

```{r plot_RC}
output$out_RC_plotly <- plotly::renderPlotly({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(
    need(!is.null(rv_param_temp$cover_subdat), message = "Relative cover is estimated when the grouping level is 'Functional Group' or 'Taxon' with at least one selected sublevel. Press the green 'UPDATE COVER SUMMARIES' button after selection."))
  
  shiny::req(!is.null(input$sel_splitplot), !is.null(input$PC_blackwhite), !is.null(input$sel_error), !is.null(rv_param_temp$sel_showRSS), !is.null(rv_param_temp$sel_lev), !is.null(input$free_ymax))
  
  shiny::validate(
    need(rv_param_temp$sel_lev!="Category", message = "Relative cover is estimated only when the grouping level is 'Functional Group' or 'Taxon'")
  )
  
  rv_param_temp$relcover_plot <- FuncPlotPointCI(dat = rv_param_temp$cover_subdat, denom = "CategoryCount", sel_error = input$sel_error, sel_splitplot = input$sel_splitplot, free_ymax = input$free_ymax, set_ymax = input$set_RC_ymax, y_text = paste0("Mean % Relative Cover (", input$sel_error, ")"), title_text = "Relative Cover per Site", which_showRSS = "cover", PC_blackwhite = input$PC_blackwhite)
  
  rv_param_temp$relcover_plot

})

plotlyOutput("out_RC_plotly")
```
</div>
</div>

% Cover (table of %cover w/CI) {data-navmenu="Group Cover per Site"}
======================================  

#### <font size="3">**This table corresponds with the left-side panel of the line graphs. The data shown are mean transect % cover and various bootstrapped confidence intervals by site and category/functional group/taxon level.**</font>

* 'EstimCov' is mean transect % cover for the category, functional group, or taxon level. Transect % cover is calculated as # of survey points in that level in that transect, divided by the adjusted number of survey points in the transect (for that survey event). The average of the transect % covers is the 'EstimCov'.

```{r}
output$out_plot_cover_tab <- DT::renderDT({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv_param_temp$cover_subdat))
  
  plot_cover_tab <- rv_param_temp$cover_subdat %>%
    dplyr::filter(DenomGroup == "TransectCount") %>%
    dplyr::select(-RSS, -DenomGroup, -SiteScale) %>%
    dplyr::mutate_at(c("ReportingSite", "Site", "IsActive", "Purpose", "Category", "NumerGroup", "NumerLevel"), as.factor) %>%
    dplyr::mutate_at(c("N"), as.integer) %>%
    dplyr::rename(
      NumTransects = N,
      GroupedBy = NumerGroup,
      GroupLevel = NumerLevel)
  
  DT::datatable(
    plot_cover_tab,
    filter = "top",
    class="compact stripe",
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      filter = "top",
      selection = "multiple",
      scrollX = TRUE,
      autoWidth = TRUE,
      pageLength = 15,
      dom = 'Blrtip',
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(15,30,45,-1),
                        c(15,30,45,"All")),
      columnDefs = list(
        list(className = 'dt_center', targets = "_all"),
        list(width = '185px', targets = c(10)) # larger column for TripName
        )
      )
  )
})
dataTableOutput("out_plot_cover_tab")
tags$style("#out_plot_cover_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Relative % Cover (table of relative cover w/CI) {data-navmenu="Group Cover per Site"} 
======================================  

#### <font size="3">**This table corresponds with the right-side panel of the line graphs. The data shown are relative % cover and various bootstrapped confidence intervals by site and functional group/taxon level.**</font>

* 'EstimCov' is RELATIVE % cover for the functional group or taxon level. It is calculated as # of survey points in that functional group or taxon level, divided by # of survey points in the broader category (e.g., CORAL). Totals for numerator and denominator are summed across all surveyed transects for that (reporting) site-survey event.

```{r}
output$out_plot_relcover_tab <- DT::renderDT({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv_param_temp$cover_subdat))
  
  plot_relcover_tab <- rv_param_temp$cover_subdat %>%
    dplyr::filter(DenomGroup == "CategoryCount") %>%
    dplyr::select(-RSS, -DenomGroup, -SiteScale) %>%
    dplyr::mutate_at(c("ReportingSite", "Site", "IsActive", "Purpose", "Category", "NumerGroup", "NumerLevel"), as.factor) %>%
    dplyr::mutate_at(c("N"), as.integer) %>%
    dplyr::rename(
      NumTransects = N,
      GroupedBy = NumerGroup,
      GroupLevel = NumerLevel)
  
  DT::datatable(
    plot_relcover_tab,
    filter = "top",
    selection = "multiple",
    class="compact stripe",
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      scrollX = TRUE,
      autoWidth = TRUE,
      pageLength = 15,
      dom = 'Blrtip',
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(15,30,45,-1),
                        c(15,30,45,"All")),
      columnDefs = list(
        list(className = 'dt_center', targets = "_all"),
        list(width = '185px', targets = c(10)) # larger column for TripName
        )
      )
  )
})
dataTableOutput("out_plot_relcover_tab")
tags$style("#out_plot_relcover_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

% Coral Bleaching (stacked bar plots) {data-navmenu="Coral Bleaching"}
======================================
Inputs {.sidebar data-width=300}
-------------------------------------
```{r input_bleach_filter}
br()

h4("Data Filter Options")

wellPanel(
  id = "wp_bleach_criteria",
  
  # Pre-filter data
  checkboxInput("bleach_RSS_active", label = "Only use active sites", value = FALSE), 
  checkboxInput("sel_bleach_episodic", label = "Include episodic survey data", value = TRUE),
  
  # Select spatial scale--sites or reporting sites
  renderUI({
    radioButtons("sel_bleach_sitescale", 
                 label = "Summarize data at this spatial scale:", 
                 choiceNames = list("Reporting Site", "Site"),
                 choiceValues = list("ReportingSite", "Site"),
                 selected = switch(is.null(input$sel_bleach_sitescale)+1, input$sel_bleach_sitescale, "Site"))
  }),
  
  tags$div(renderText({
    shiny::req(!is.null(input$sel_bleach_sitescale))
    if(input$sel_bleach_sitescale == "ReportingSite") {
      paste0("NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites")  # Explain how reporting sites are summarized
    }
  }), style = "font-size:14px;, !is. color:red; font-weight:bold;"),
  
  renderUI({
    shiny::req(!is.null(rv$bleach_CIs_df), !is.null(input$sel_bleach_sitescale), !is.null(input$bleach_RSS_active))
   
    bleach_RSS_choices <- rv$bleach_CIs_df %>%
      dplyr::filter(if(input$bleach_RSS_active == TRUE) IsActive == 1 else TRUE) %>%
      {if(input$sel_bleach_sitescale == "Site") dplyr::pull(., Site) else dplyr::pull(., ReportingSite)} %>% unique(.) %>% na.omit(.)
    
    # Select (reporting) sites
    checkboxGroupInput("sel_bleach_showRSS", 
                       label = paste0("Show results for these ", if_else(input$sel_bleach_sitescale == "ReportingSite", "reporting sites", "sites")),
                       choices = bleach_RSS_choices, 
                       selected = if(!is.null(input$sel_bleach_showRSS) & all(input$sel_bleach_showRSS %in% bleach_RSS_choices)) {input$sel_bleach_showRSS} else {bleach_RSS_choices}) # if selections already made and they are a subset of RSS_choices, then use those selections; otherwise, use RSS_choices as default
  }),
  
  br(),
  
  actionButton("button_update_bleach", "UPDATE BLEACH SUMMARIES", class = "green-action-button")
) # end of 'wp_bleach_criteria'
```

```{r input_bleach_format}

h4("Figure Format Options (plots update immediately)")

checkboxInput("bleach_free_ymax", label = "Allow y-axes scales to vary among `% cover of site` plots", value = TRUE)
```

% Bleach and Relative Bleach per Site
-------------------------------------
#### <font size="3">**These stacked bar plots show % cover by bleach level (left-side panel) and relative % cover by bleach level (right-side panel) for each selected site and category/functional group/taxon level**</font>

<span style="font-size:18px; color:red;">
    STACKED BAR PLOTS ARE SLOW TO DRAW - PLEASE BE PATIENT 
</span>

* % cover is calculated as # of survey points in that level in that transect, divided by the adjusted number of survey points in the transect (for that survey event). The AVERAGE of the transect % covers for that (reporting) site-survey event is shown by the bar height for that bleach level.

* Relative % cover is calculated as # of survey points in that coral bleaching level, divided by # of survey points classified as CORAL. Totals for numerator and denominator are summed across all surveyed transects for that (reporting) site-survey event.

####
```{r bleach_legend}
renderPlot({
  shiny::req(!is.null(rv$bleach_CIs_df), !is.null(rv_param_temp$bleach_subdat))
  bleach_barplot_legend <-
    ggpubr::as_ggplot(cowplot::get_legend(
  ggplot(data.frame(x=1:6, y = 1:6, BleachLevel = c("NoData", "UNBL", "BL1", "BL2", "BL3", "BL4")), aes(x = x, y = y, fill = BleachLevel)) +
    geom_col() + 
    scale_fill_manual(values = c("NoData" = "orange", "UNBL" = "gray25", "BL1" = "gray45", "BL2" = "gray55", "BL3" = "gray75", "BL4" = "gray92"), guide = guide_legend(override.aes = list(size=1.25))) + 
    theme_bw(base_size = 12) +
    theme(legend.position = "top",
          legend.text = element_text(size = 16),
          legend.title = element_text(size = 16))
  ))
  grid.arrange(bleach_barplot_legend)
}, height = 40)
```

####
<div class="flex-container">
<div class="flex-left">
  
<center><h3>Coral Bleaching as % Cover of Site</h3></center>
<br>
```{r barplot_bleachPC}
output$out_bleach_stackplot <- renderPlotly({
  
  shiny::validate(need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(need(!is.null(rv_param_temp$bleach_subdat), message = "From 'Data Filter Options' on the line graphs page, please select site(s), then press the green 'UPDATE BLEACH SUMMARIES' button"))
  
  shiny::req(!is.null(rv_param_temp$sel_bleach_showRSS), !is.null(rv_param_temp$bleach_pc_plot))

  rv_param_temp$bleach_pc_plot
})

plotlyOutput("out_bleach_stackplot")
```

</div>
<div class="flex-right">
  
<center><h3>Coral Bleaching as % Cover of Corals</h3></center>
<br>
```{r barplot_bleachRC}
output$out_bleach_stackplot2 <- renderPlotly({
  
  shiny::validate(need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(need(!is.null(rv_param_temp$bleach_subdat), message = "From 'Data Filter Options' on the line graphs page, please select site(s), then press the green 'UPDATE BLEACH SUMMARIES' button"))
  
  shiny::req(!is.null(rv_param_temp$sel_bleach_showRSS), !is.null(rv_param_temp$bleach_rc_plot))

  rv_param_temp$bleach_rc_plot
})
      

# htmltools::div(style = "display:inline-block", plotlyOutput("out_bleach_stackplot2", height = reactive({switch(is.null(rv_param_temp$sel_bleach_showRSS)+1, length(rv_param_temp$sel_bleach_showRSS) * 250 + 150, 200)})))

 # plotlyOutput("out_bleach_stackplot2", height = reactive({switch(is.null(rv_param_temp$sel_bleach_showRSS)+1, length(rv_param_temp$sel_bleach_showRSS) * 250 + 150, 200)}))
plotlyOutput("out_bleach_stackplot2")

```
</div>
</div>
  
% Bleaching (table of %cover w/CI) {data-navmenu="Coral Bleaching"}
======================================
#### <font size="3">**This table corresponds with the left-side panel of the coral bleaching stacked bar graphs, but also provides confidence intervals. For each site, the data shown are % cover by bleach level and various bootstrapped confidence intervals.**</font>

* % cover is calculated as # of survey points in that level in that transect, divided by the adjusted number of survey points in the transect (for that survey event). The average of the transect % covers is the 'EstimCov'.

* Confidence intervals are bootstrapped. For a NORMALLY distributed characteristic, the 68% CI is equal to the mean cover estimate +/- 1 standard error.

```{r}
output$out_bleach_tab <- DT::renderDT({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv_param_temp$bleach_subdat))
  
  bleach_tab <- rv_param_temp$bleach_subdat %>% # for easier filtering
    dplyr::filter(DenomGroup == "TransectCount") %>%
    dplyr::select(-RSS, -DenomGroup, -SiteScale) %>%
    dplyr::select(ReportingSite, Site, IsActive, Year, everything()) %>% # rearrange column order
        dplyr::mutate_at(c("ReportingSite", "Site", "IsActive", "Purpose", "Category", "NumerGroup", "NumerLevel"), as.factor) %>%
    dplyr::mutate_at(c("N", "Year"), as.integer) %>%
    dplyr::rename(
      NumTransects = N,
      GroupedBy = NumerGroup,
      GroupLevel = NumerLevel)
  
  DT::datatable(
    bleach_tab,
    filter = "top",
    class="compact stripe",
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      filter = "top",
      selection = "multiple",
      scrollX = TRUE,
      autoWidth = TRUE,
      pageLength = 15,
      dom = 'Blrtip',
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(15,30,45,-1),
                        c(15,30,45,"All")),
      columnDefs = list(
        list(className = 'dt_center', targets = "_all") # larger column for TripName
      )
    )
  )
})

dataTableOutput("out_bleach_tab")
tags$style("#out_bleach_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
``` 

Relative % Bleaching (table of relative cover w/CI) {data-navmenu="Coral Bleaching"}
======================================
#### <font size="3">**This table corresponds with the right-side panel of the coral bleaching line graphs, but also provides confidence intervals. For each site, the data shown are relative % cover by bleach level and various bootstrapped confidence intervals.**</font>

* 'EstimCov' is RELATIVE % cover by bleach level. It is calculated as # of survey points in that coral bleaching level, divided by # of survey points classified as CORAL. Totals for numerator and denominator are summed across all surveyed transects for that (reporting) site-survey event.

* Confidence intervals are bootstrapped. For a NORMALLY distributed characteristic, the 68% CI is equal to the mean cover estimate +/- 1 standard error.

```{r}
output$out_relbleach_tab <- DT::renderDT({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv_param_temp$bleach_subdat))
  
  relbleach_tab <- rv_param_temp$bleach_subdat %>% # for easier filtering
    dplyr::filter(DenomGroup == "CategoryCount") %>%
    dplyr::select(-RSS, -DenomGroup, -SiteScale) %>%
    dplyr::select(ReportingSite, Site, IsActive, Year, everything()) %>% # rearrange column order
    dplyr::mutate_at(c("ReportingSite", "Site", "IsActive", "Purpose", "Category", "NumerGroup", "NumerLevel"), as.factor) %>%
    dplyr::mutate_at(c("N", "Year"), as.integer) %>%
    dplyr::rename(
      NumTransects = N,
      GroupedBy = NumerGroup,
      GroupLevel = NumerLevel)
  
  DT::datatable(
    relbleach_tab,
    filter = "top",
    class="compact stripe",
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      filter = "top",
      selection = "multiple",
      scrollX = TRUE,
      autoWidth = TRUE,
      pageLength = 15,
      dom = 'Blrtip',
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(15,30,45,-1),
                        c(15,30,45,"All")),
      columnDefs = list(
        list(className = 'dt_center', targets = "_all") # larger column for TripName
      )
    )
  )
})

dataTableOutput("out_relbleach_tab")
tags$style("#out_relbleach_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
``` 

Disease Counts {data-navmenu="Coral Disease"}
======================================
Inputs {.sidebar data-width=300}
-------------------------------------
```{r input_disease_filter}
br()

h4("Data Filter Options")

wellPanel(
  id = "wp_disease_criteria",
  
  # Pre-filter data
  checkboxInput("disease_RSS_active", label = "Only use active sites", value = FALSE), 
  checkboxInput("sel_disease_episodic", label = "Include episodic survey data", value = TRUE),
  
  # Select spatial scale--sites or reporting sites
  renderUI({
    radioButtons("sel_disease_sitescale", 
                 label = "Summarize data at this spatial scale:", 
                 choiceNames = list("Reporting Site", "Site"),
                 choiceValues = list("ReportingSite", "Site"),
                 selected = switch(is.null(input$sel_disease_sitescale)+1, input$sel_disease_sitescale, "Site"))
  }),
  
    tags$div(renderText({
    shiny::req(!is.null(input$sel_disease_sitescale))
    if(input$sel_disease_sitescale == "ReportingSite") {
      paste0("NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites")  # Explain how reporting sites are summarized
    }
  }), style = "font-size:14px;, !is. color:red; font-weight:bold;"),
  
  br(),
  
  renderUI({
    shiny::req(!is.null(rv$disease_df), !is.null(input$sel_disease_sitescale), !is.null(input$disease_RSS_active))
    
    disease_RSS_choices <- rv$disease_df %>%
      dplyr::filter(if(input$disease_RSS_active == TRUE) IsActive == 1 else TRUE) %>%
      {if(input$sel_disease_sitescale == "Site") dplyr::pull(., Site) else dplyr::pull(., ReportingSite)} %>% unique(.) %>% na.omit(.)
    
    # Select (reporting) sites
    checkboxGroupInput("sel_disease_showRSS", 
                       label = paste0("Show results for these ", if_else(input$sel_disease_sitescale == "ReportingSite", "reporting sites", "sites")),
                       choices = disease_RSS_choices, 
                       selected = if(!is.null(input$sel_disease_showRSS) & all(input$sel_disease_showRSS %in% disease_RSS_choices)) {input$sel_disease_showRSS} else {disease_RSS_choices}) # if selections already made and they are a subset of RSS_choices, then use those selections; otherwise, use RSS_choices as default
  }),
  
  renderUI({
    shiny::req(!is.null(rv$disease_df), !is.null(input$sel_disease_sitescale), !is.null(input$sel_disease_showRSS), !is.null(input$sel_disease_episodic))
    
    rv_param_temp$avail_diseases <- rv$disease_df %>%
      dplyr::rename(RSS = input$sel_disease_sitescale) %>%
      dplyr::filter(
        RSS %in% input$sel_disease_showRSS,
        if(input$sel_disease_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
      pull(DiseaseCode) %>%
      unique() %>%
      sort()
    
    checkboxGroupInput("sel_diseases",
                       label = "Include these diseases",
                       choices = rv_param_temp$avail_diseases,
                       selected = input$sel_diseases)
  }),
  
  actionButton("disease_all_button", "Select All", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  actionButton("disease_none_button", "Select None", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  actionButton("disease_tissue_loss_button", "Select Tissue Loss Diseases & YB", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  actionButton("disease_discoloration_button", "Select Discoloration Diseases", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),

  br(),
  
  br(),

  actionButton("button_update_disease", "UPDATE DISEASE SUMMARIES", class = "green-action-button")
) # end of 'wp_disease_criteria'
```

```{r input_disease_format}

h4("Figure Format Options (plots update immediately)")

checkboxInput("disease_by_transect", label = "Show separate line for each transect (line graphs only)", value = FALSE)

checkboxInput("disease_free_ymax", label = "Allow y-axes scales to vary among line graphs", value = TRUE)

renderUI({
  shiny::req(!is.null(rv_param_temp$disease_RSS), input$disease_free_ymax == FALSE) # this option is only shown when y-axes scales are not allowed to vary among plots
  top_count <-max(rv_param_temp$disease_RSS$SiteDiseased, na.rm = TRUE) %>% plyr::round_any(., 5, f = ceiling)
  numericInput("set_disease_count_ymax", label = "Set y-axis maximum for diseased colonies count line graphs", min = 1, max = top_count, step = 1, value = top_count)
})
```

Disease Counts
-------------------------------------

#### <font size="3">**These figures show count of diseased colonies, summed over selected diseases.**</font>

<span style="font-size:18px; color:red;">
    STACKED BAR PLOTS ARE SLOW TO DRAW - PLEASE BE PATIENT 
</span>

* Disease counts are summaries of the survey data collected from sample transects, without inference to the study site (therefore, no estimates of statistical error).

* All coral colonies that overlap survey transects are included. See protocol for how "coral colony" is defined.

####
<div class="flex-container">
<div class="flex-left">
  
<center><h3>Number of Diseased Coral Colonies Along Transects</h3></center>
<br>
```{r plot_disease_count}
output$out_disease_count_plotly <- plotly::renderPlotly({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(
    need(!is.null(rv_param_temp$disease_RSS) & !is.null(rv_param_temp$disease_transect), message = "From 'Data Filter Options' on the left, please select site(s) and disease(s), then press the green 'UPDATE DISEASE SUMMARIES' button"))
  
  shiny::req(!is.null(input$disease_free_ymax), !is.null(rv_param_temp$sel_disease_showRSS))
  
  rv_param_temp$disease_count_plot <- FuncPlotPointDisease(dat = switch((input$disease_by_transect == TRUE)+1, rv_param_temp$disease_RSS, rv_param_temp$disease_transect), metric = switch((input$disease_by_transect == TRUE)+1, "SiteDiseased", "TransectDiseased"), free_ymax = input$disease_free_ymax, set_ymax = input$set_disease_count_ymax, y_text = "Number of Diseased Coral Colonies Detected", disease_by_transect = input$disease_by_transect)
  
  rv_param_temp$disease_count_plot$plot %>% hide_legend(.)
})
plotlyOutput("out_disease_count_plotly")
```

</div>
<div class="flex-right">
  
<center><h3>Number of Diseased (red) and Non-Diseased (black) Coral Colonies Along Transects</h3></center>
<br>

```{r barplot_disease_count}
output$out_disease_count_stackplot <- renderPlot({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(
    need(!is.null(rv_param_temp$disease_RSS) & !is.null(rv_param_temp$disease_transect), message = "From 'Data Filter Options' on the left, please select site(s) and disease(s), then press the green 'UPDATE DISEASE SUMMARIES' button"))
  
  disease_counts_dat <- rv_param_temp$disease_RSS %>%
    ungroup() %>%
    dplyr::select(RSS, Year, SurvDate, Diseased = SiteDiseased, NotDiseased = SiteNotDiseased) %>%
    dplyr::arrange(RSS, SurvDate) %>%
    dplyr::mutate(SurvDate = as.factor(SurvDate)) %>% # this is for the bar charts
    tidyr::pivot_longer(cols = c("Diseased", "NotDiseased"), names_to = "DiseaseStatus", values_to = "NumColonies")
  
  shiny::req(!is.null(disease_counts_dat))
  
  FuncPlotDisease(dat = disease_counts_dat, y_col = "NumColonies", yaxis_title = "Number of Coral Colonies")
},
  height = function(){shiny::validate(need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"));shiny::validate(need(!is.null(rv_param_temp$disease_RSS) & !is.null(rv_param_temp$disease_transect), message = "From 'Data Filter Options' on the line graphs page, please select site(s) and disease(s), then press the green 'UPDATE DISEASE SUMMARIES' button"));shiny::req(!is.null(rv_param_temp$sel_disease_showRSS));150+length(rv_param_temp$sel_disease_showRSS)*250}
)

plotOutput("out_disease_count_stackplot")
```

</div>
</div>

Lesion Counts & Area {data-navmenu="Coral Disease"}
======================================

Inputs {.sidebar data-width=300}
-------------------------------------

#### <font size="3">**These line graphs show count and area of disease lesions, summed over selected tissue loss (or YB) diseases.**</font>

* Lesion metrics are shown only for tissue loss diseases and YB (does not include blemishes of discoloration diseases such as Dark Spot).

* Lesion counts and area are summaries of the survey data collected along sample transects, without inference to the study site (therefore, no estimates of statistical error).

* Lesion area is calculated as (longest) length X (widest) width of lesion, so likely overestimates actual area.

* All coral colonies that overlap survey transects are included. See protocol for how "coral colony" is defined.

<span style="font-size:14px; color:red;">
    NOTE: Lesion area is not standardized by coral area. In any year, low lesion area values may be due to low tissue loss disease OR due to low coral area along transect.
</span>

####

```{r input_lesion_format}
br()

h4("Figure Format Options (plots update immediately)")

checkboxInput("lesion_by_transect", label = "Show separate line for each transect", value = FALSE)

checkboxInput("lesion_free_ymax", label = "Allow y-axes scales to vary among line graphs", value = TRUE)

renderUI({
  shiny::req(!is.null(rv_param_temp$lesion_RSS), !is.null(rv_param_temp$lesion_transect), input$lesion_free_ymax == FALSE) # this option is only shown when y-axes scales are not allowed to vary among plots
  top_lesion_count <-max(rv_param_temp$lesion_RSS$SiteLesionCounts, na.rm = TRUE) %>% plyr::round_any(., 5, f = ceiling)
  numericInput("set_lesion_count_ymax", label = "Set y-axis maximum for lesion count", min = 1, max = top_lesion_count, step = 5, value = top_lesion_count)
})

renderUI({
  shiny::req(!is.null(rv_param_temp$lesion_RSS), !is.null(rv_param_temp$lesion_transect), input$lesion_free_ymax == FALSE) # this option is only shown when y-axes scales are not allowed to vary among plots
  top_lesion_area <-max(rv_param_temp$lesion_RSS$SiteLesionArea, na.rm = TRUE) %>% plyr::round_any(., 10, f = ceiling)
  numericInput("set_lesion_area_ymax", label = "Set y-axis maximum for lesion area", min = 0.1, max = top_lesion_area, step = 10, value = top_lesion_area)
})
```

Lesion Counts & Area
-------------------------------------

####
<div class="flex-container">
<div class="flex-left">
  
<center><h3>Number of Disease Lesions Along Transects</h3></center>
<br>
```{r plot_lesion_count}
output$out_lesion_count_plotly <- plotly::renderPlotly({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(
    need(!is.null(rv_param_temp$lesion_RSS), message = "From 'Data Filter Options', please select site(s) and at least one tissue loss disease or YB, then press the green 'UPDATE DISEASE SUMMARIES' button"))
  
  shiny::req(!is.null(rv_param_temp$sel_disease_showRSS), !is.null(input$lesion_free_ymax))
  
  rv_param_temp$lesion_count_plot <- FuncPlotPointLesion(dat = switch((input$lesion_by_transect == TRUE)+1, rv_param_temp$lesion_RSS, rv_param_temp$lesion_transect), metric = switch((input$lesion_by_transect == TRUE)+1, "SiteLesionCounts", "TransectLesionCounts"), free_ymax = input$lesion_free_ymax, set_ymax = input$set_lesion_count_ymax, y_text = "Number of Disease Lesions Detected on Transects", disease_by_transect = input$lesion_by_transect)
  
  rv_param_temp$lesion_count_plot$plot %>% hide_legend(.)
})
plotlyOutput("out_lesion_count_plotly")
```

</div>
<div class="flex-right">
  
<center><h3>Summed Lesion Areas Along Transects</h3></center>
<br>
```{r plot_lesion_area}
output$out_lesion_area_plotly <- plotly::renderPlotly({
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(
    need(!is.null(rv_param_temp$lesion_RSS), message = "From 'Data Filter Options', please select site(s) and at least one tissue loss disease or YB, then press the green 'UPDATE DISEASE SUMMARIES' button"))
 
  shiny::req(!is.null(rv_param_temp$sel_disease_showRSS), !is.null(input$lesion_free_ymax))
  
  rv_param_temp$lesion_area_plot <- FuncPlotPointLesion(dat = switch((input$lesion_by_transect == TRUE)+1, rv_param_temp$lesion_RSS, rv_param_temp$lesion_transect), metric = switch((input$lesion_by_transect == TRUE)+1, "SiteLesionArea", "TransectLesionArea"), free_ymax = input$lesion_free_ymax, set_ymax = input$set_lesion_area_ymax, y_text = "Summed Lesion Area Across Transects", disease_by_transect = input$lesion_by_transect)
  
  rv_param_temp$lesion_area_plot$plot %>% hide_legend(.)
})
plotlyOutput("out_lesion_area_plotly")
```
</div>
</div>
    
Disease Prevalence {data-navmenu="Coral Disease"}
======================================

Inputs {.sidebar data-width=300}
-------------------------------------

#### <font size="3">**These figures show disease prevalence, summed over selected diseases.**</font>
  
* Disease prevalence is a summary of the survey data collected from sample transects, without inference to the study site (therefore, no estimates of statistical error).

* All coral colonies that overlap survey transects are included. See protocol for how "coral colony" is defined.

<span style="font-size:14px; color:red;">
  NOTE: Disease prevalence is calculated as NUMBER OF CORAL COLONIES WITH DISEASE (numerator) divided by the COUNT OF STONY CORAL COLONIES (denominator), expressed as a percentage. Numerator and denominator counts may be conducted by different persons, without correcting for observer differences.
</span>

####

```{r input_disease_prev_format}

br()

h4("Figure Format Options (plots update immediately)")

checkboxInput("disease_prev_by_transect", label = "Show separate line for each transect (line graphs only)", value = FALSE)

checkboxInput("disease_prev_free_ymax", label = "Allow y-axes scales to vary among line graphs", value = TRUE)

renderUI({
  shiny::req(!is.null(rv_param_temp$disease_transect), input$disease_prev_free_ymax == FALSE) # this option is only shown when y-axes scales are not allowed to vary among plots
  top_prev <-max(rv_param_temp$disease_transect$TransectPrev, na.rm = TRUE) %>% plyr::round_any(., 0.2, f = ceiling)
  numericInput("set_disease_prev_ymax", label = "Set y-axis maximum for disease prevalence line graphs", min = 0.1, max = top_prev, step = 0.1, value = top_prev)
})
```

Disease Prevalence
-------------------------------------

####
<div class="flex-container">
  <div class="flex-left">
  
<center><h3>Coral Disease Prevalence Along Transects</h3></center>
<br>
```{r plot_disease_prev}
output$out_disease_prev_plotly <- plotly::renderPlotly({
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(
    need(!is.null(rv_param_temp$disease_RSS) & !is.null(rv_param_temp$disease_transect), message = "From 'Data Filter Options', please select site(s) and disease(s), then press the green 'UPDATE DISEASE SUMMARIES' button"))
 
  shiny::req(!is.null(input$disease_prev_free_ymax), !is.null(rv_param_temp$sel_disease_showRSS))
  
  rv_param_temp$disease_prev_plot <- FuncPlotPointDisease(dat = switch((input$disease_prev_by_transect == TRUE)+1, rv_param_temp$disease_RSS, rv_param_temp$disease_transect), metric = switch((input$disease_prev_by_transect == TRUE)+1, "SitePrev", "TransectPrev"), free_ymax = input$disease_prev_free_ymax, set_ymax = input$set_disease_prev_ymax, y_text = "% of Coral Colonies with Disease", disease_by_transect = input$disease_prev_by_transect)
  
  rv_param_temp$disease_prev_plot$plot %>% hide_legend(.)
})
plotlyOutput("out_disease_prev_plotly")
```

</div>
<div class="flex-right">
  
<center><h3>Stony Coral Counts, by Transect</h3></center>
<br>
  
```{r barplot_disease_colcount_tab}
output$out_disease_transect_minitab <- DT::renderDT({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv_param_temp$disease_transect))
  
  disease_transect_minitab <- rv_param_temp$disease_transect %>%
    dplyr::select(Site_Transect, SurvDate, StonyCoralCount1, StonyCoralCount2, StonyCoralCountDIFF) %>%
    dplyr::mutate_at(c("StonyCoralCount1", "StonyCoralCount2", "StonyCoralCountDIFF"), as.integer) %>%
    dplyr::arrange(desc(StonyCoralCountDIFF))
  
  DT::datatable(
    disease_transect_minitab,
    filter = "top",
    class="compact stripe",
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      caption = "Arranged by StonyCoralCountDIFF, in descending order",
      filter = "top",
      selection = "multiple",
      scrollX = TRUE,
      autoWidth = TRUE,
      pageLength = 15,
      dom = 'Blrtip',
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(15,30,45,-1),
                        c(15,30,45,"All")),
      columnDefs = list(
        list(className = 'dt_center', targets = "_all") # larger column for TripName
      )
    )
  )
})

dataTableOutput("out_disease_transect_minitab")
tags$style("#out_disease_transect_minitab{height:100vh}")
```
  
</div>
</div>

Disease Counts & Prevalence (table of site-level data) {data-navmenu="Coral Disease"}
======================================

#### <font size="3">**This table shows reporting site/site-level disease count and prevalence.**</font>

* Counts and prevalence are summaries of the survey data collected from sample transects, without estimates of statistical error.

* All coral colonies that overlap survey transects are included. See protocol for how "coral colony" is defined.

<span style="font-size:14px; color:red;">
    NOTE: Disease prevalence is calculated as NUMBER OF CORAL COLONIES WITH DISEASE (numerator) divided by the COUNT OF STONY CORAL COLONIES (denominator), expressed as a percentage. Numerator and denominator counts may be conducted by different persons, without correcting for observer differences.
</span>

```{r}
output$out_disease_prev_tab <- DT::renderDT({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv_param_temp$disease_RSS))
  
  disease_prev_tab <- rv_param_temp$disease_RSS %>%
    dplyr::select(ParkCode, RSS, Year, SurvDate, Purpose, ProtocolVersion, ColCountsCertificationLevel, SiteDiseased, SiteNotDiseased, SiteStonyCoralCountAVG, SitePrev) %>%
    dplyr::mutate_at(c("ParkCode", "RSS", "Purpose", "ProtocolVersion", "ColCountsCertificationLevel"), as.factor) %>%
    dplyr::mutate_at(c("Year", "SiteDiseased", "SiteNotDiseased"), as.integer) %>%
    dplyr::rename(
      NumColoniesDiseased = SiteDiseased,
      NumColoniesNOTDiseased = SiteNotDiseased,
      DiseasePrevalence = SitePrev)
  
  DT::datatable(
    disease_prev_tab,
    filter = "top",
    class="compact stripe",
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      filter = "top",
      selection = "multiple",
      scrollX = TRUE,
      autoWidth = TRUE,
      pageLength = 15,
      dom = 'Blrtip',
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(15,30,45,-1),
                        c(15,30,45,"All")),
      columnDefs = list(
        list(className = 'dt_center', targets = "_all") # larger column for TripName
      )
    )
  )
})

dataTableOutput("out_disease_prev_tab")
tags$style("#out_disease_prev_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
``` 

Disease Counts & Prevalence (table of transect-level data) {data-navmenu="Coral Disease"}
======================================

#### <font size="3">**This table shows transect-level disease count and prevalence.**</font>

* Counts and prevalence are summaries of the survey data collected from sample transects, without estimates of statistical error.

* All coral colonies that overlap survey transects are included. See protocol for how "coral colony" is defined.

<span style="font-size:14px; color:red;">
    NOTE: Disease prevalence is calculated as NUMBER OF CORAL COLONIES WITH DISEASE (numerator) divided by the COUNT OF STONY CORAL COLONIES (denominator), expressed as a percentage. Numerator and denominator counts may be conducted by different persons, without correcting for observer differences.
</span>

```{r}
output$out_disease_transect_tab <- DT::renderDT({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv_param_temp$disease_transect))
  
  disease_transect_tab <- rv_param_temp$disease_transect %>%
    dplyr::select(-RSS, -Site_Transect, -TransectSurveyID) %>%
    dplyr::select(ParkCode, ReportingSite, ReportingSiteName, Site, IsActive, Year, SurvDate, Purpose, ProtocolVersion, ColCountsCertificationLevel, Transect, TransectDiseased, TransectNotDiseased, TransectPrev, StonyCoralCount1, StonyCoralCount2, StonyCoralCountAVG, StonyCoralCountDIFF) %>%
    dplyr::mutate_at(c("ParkCode", "ReportingSite", "ReportingSiteName", "Site", "IsActive", "Purpose", "ProtocolVersion", "Transect", "ColCountsCertificationLevel"), as.factor) %>%
    dplyr::mutate_at(c("Year", "TransectDiseased", "TransectNotDiseased", "StonyCoralCount1", "StonyCoralCount2", "StonyCoralCountDIFF"), as.integer) %>%
    dplyr::rename(
      NumColoniesDiseased = TransectDiseased,
      NumColoniesNOTDiseased = TransectNotDiseased,
      AvgNumColonies = StonyCoralCountAVG,
      DiseasePrevalence = TransectPrev)
  
  DT::datatable(
    disease_transect_tab,
    filter = "top",
    class="compact stripe",
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      filter = "top",
      selection = "multiple",
      scrollX = TRUE,
      autoWidth = TRUE,
      pageLength = 15,
      dom = 'Blrtip',
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(15,30,45,-1),
                        c(15,30,45,"All")),
      columnDefs = list(
        list(className = 'dt_center', targets = "_all") # larger column for TripName
      )
    )
  )
})

dataTableOutput("out_disease_transect_tab")
tags$style("#out_disease_transect_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
``` 

Cover & Bleaching Data {data-navmenu="Raw Data Tables"}
====================================

#### <font size="3">**Cover and Coral Bleaching**</font>

```{r}
output$out_cover_tab <- DT::renderDT({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  cov_tab <- rv$raw_dat %>% # for easier filtering
    dplyr::mutate_at(c("ParkCode", "ReportingSite", "ReportingSiteName", "Site", "IsActive", "Purpose", "Category", "Subcategory", "FunctionalGroup", "Taxon", "BleachingCode", "VideoCertificationLevel"), as.factor) %>%
    dplyr::mutate_at(c("Transect", "Year", "CountOfTaxon"), as.integer)
  
  DT::datatable(
    cov_tab,
    filter = "top",
    class="compact stripe",
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      filter = "top",
      selection = "multiple",
      scrollX = TRUE,
      autoWidth = TRUE,
      pageLength = 15,
      dom = 'Blrtip',
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(15,30,45,-1),
                        c(15,30,45,"All")),
      columnDefs = list(
        list(className = 'dt_center', targets = "_all"),
        list(width = '210px', targets = c(10)) # larger column for TripName
        )
      )
  )
})
dataTableOutput("out_cover_tab")
tags$style("#out_cover_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Disease Data {data-navmenu="Raw Data Tables"}
====================================

#### <font size="3">**Coral Disease**</font>

```{r}
output$out_disease_tab <- DT::renderDT({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv$disease_df))
  
    disease_tab <- rv$disease_df %>% # for easier filtering
    dplyr::mutate_at(c("ParkCode", "ReportingSite", "ReportingSiteName", "Site", "IsActive", "Purpose", "DiseaseCode", "DiseaseDescription", "Taxon", "CoralScientificName", "DiseaseCertificationLevel"), as.factor) %>%
    dplyr::mutate_at(c("Transect", "ColonyNumber", "DiscoloredTissue", "NumOfBlemishes"), as.integer)
  
  DT::datatable(
    disease_tab,
    filter = "top",
    class="compact stripe",
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      filter = "top",
      selection = "multiple",
      scrollX = TRUE,
      autoWidth = TRUE,
      pageLength = 15,
      dom = 'Blrtip',
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(15,30,45,-1),
                        c(15,30,45,"All")),
      columnDefs = list(
        list(className = 'dt_center', targets = "_all"))
      )
  )
})

dataTableOutput("out_disease_tab")
tags$style("#out_disease_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Colony Counts Data {data-navmenu="Raw Data Tables"}
====================================

#### <font size="3">**Colony Counts**</font>

```{r}
output$out_colcounts_tab <- DT::renderDT({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv$colcounts_df))
  
  colcounts_tab <- rv$colcounts_df %>% # for easier filtering
    dplyr::mutate_at(c("ParkCode", "ReportingSite", "ReportingSiteName", "Site", "IsActive", "Purpose", "ColCountsCertificationLevel"), as.factor) %>%
    dplyr::mutate_at(c("Transect", "StonyCoralCount1", "StonyCoralCount2"), as.integer)
  
  DT::datatable(
    colcounts_tab,
    filter = "top",
    class="compact stripe",
    rownames= FALSE,
    extensions=c('Buttons'),
    options = list(
      filter = "top",
      selection = "multiple",
      scrollX = TRUE,
      autoWidth = TRUE,
      pageLength = 15,
      dom = 'Blrtip',
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(15,30,45,-1),
                        c(15,30,45,"All")),
      columnDefs = list(
        list(className = 'dt_center', targets = "_all"),
        list(width = '210px', targets = c(10)) # larger column for TripName
        )
      )
  )
})

dataTableOutput("out_colcounts_tab")
tags$style("#out_colcounts_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```