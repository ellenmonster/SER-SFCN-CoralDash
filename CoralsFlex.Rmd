---
title: "SFCN Coral Reefs"
output:
  flexdashboard::flex_dashboard:
    vertical_layout: scroll
    orientation: columns
    theme: sandstone   # theme options: default, cosmo, bootstrap, cerulean, journal, flatly, readable, spacelab, united, lumen, paper, sandstone, simplex, yeti
runtime: shiny
---

```{r global, include=FALSE}

rm(list=ls())

### Load libraries -----
# Will automatically install any packages it can't find

pkgList <- c("flexdashboard", "shiny", "knitr", "gridExtra", "shinyWidgets", "leaflet", "plotly", "DT", "rtf", "lubridate", "leaflet.minicharts", "tidyverse", "htmlwidgets", "RSQLite", "multidplyr", "Rcpp", "reactable", "scales")
inst <- pkgList %in% installed.packages()
if (length(pkgList[!inst]) > 0) install.packages(pkgList[!inst],dep=TRUE)
lapply(pkgList, library, character.only = TRUE)

options(shiny.maxRequestSize = 20*1024^2) # allows data files up to 20 MB to be imported
source("Corals.R")

rv <- reactiveValues(raw_dat = NULL, map_dat = NULL, groups_df = NULL, warn_list = NULL, cover_CIs_df = NULL, bleach_CIs_df = NULL)

rv_param_temp <- reactiveValues(dat_PC = NULL, avail_sublevs = NULL, sel_showRSS = NULL, sel_sublev = NULL, shared_legends)

```

```{r functions}

FuncPlotPointCI <- function(dat = rv_param_temp$dat_PC, denom = "TransectCount", sel_error = "90%CI", sel_splitplot = input$sel_splitplot, PCy_max = input$PCy_max, y_text = paste0("% Cover (", input$sel_error, ")"), PC_blackwhite = input$PC_blackwhite) {
  # Function to generate point plots with error bars
  #
  # Args:
  #   CI_dat:  The CI data frame
  #   denom: "TransectCount" for % cover or "CategoryCount" for relative % cover
  #   combine_stations:  TRUE to combine multiple stations in a single plot of a characteristic
  #   fixed_free_y:  Are scales fixed or free across all plots?
  #
  # Returns:
  #   List of point plots with error bars
  # 
  
  # Colorblind-friendly palette
  cbp1 <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7", "#0072B2", "#D55E00", "#999999", "#F0E442", "#000000", "chocolate4", "purple4", "chartreuse", "lightpink", "honeydew2") 
  
  # Set up the data
  plot_dat <- dat %>%
    dplyr::filter(DenomGroup == denom) %>% 
    dplyr::rename(
      y_val = EstimCov,
      CI_low = contains(paste0(sel_error, "_low")),
      CI_high = contains(paste0(sel_error, "_high")))
  
  # All plots share a single x-axis
  xaxes_min = min(plot_dat$SurvDate, na.rm = TRUE)
  xaxes_max = max(plot_dat$SurvDate, na.rm = TRUE)
  
  # Plot-end function
  FuncPlotEnd <- function(p) {
    p_final <- p + 
      scale_x_date(date_breaks = "1 year", date_labels = "%Y", breaks = scales::pretty_breaks(), limits = c(xaxes_min, xaxes_max)) +
      scale_y_continuous(breaks = pretty_breaks()) +
      expand_limits(y = switch(is.null(PCy_max)+1, c(0, PCy_max, 0), 0)) +
      theme_bw(base_size = 12) +
      theme(strip.text = element_text(size = 12, face = "bold"),
            strip.text.y = element_blank(), 
            legend.title = element_blank(),
            legend.position = "top") 
    
    return(p_final)
  }
  
  # Create the plot(s)
  p_points_list <- list()
  
  # One_loc_one_sub
  if(sel_splitplot == "one_loc_one_sub") {
    unique_df <- plot_dat %>%
      dplyr::select(RSS, NumerLevel) %>% 
      dplyr::distinct() %>%
      arrange(RSS, NumerLevel)
    
    for (v in 1:nrow(unique_df)) { # for each loc-sub
      dat_df <- plot_dat %>%
        dplyr::filter(RSS == unique_df$RSS[v] & NumerLevel == unique_df$NumerLevel[v])
      
      p_points <- 
        ggplot(data = dat_df, aes(x = SurvDate, y = y_val, N = N, CI_low = CI_low, CI_high = CI_high)) +
        labs(x = "Year", y = y_text) +
        geom_point(aes(text = paste0("Reporting Site: ", ReportingSite, "<br>Site: ", Site, "<br>Survey Date: ", SurvDate, "<br>N: ", N, "<br>% Cover: ", y_val, "<br>CI low end: ", CI_low, "<br>CI high end: ", CI_high)), size = 2) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works
        geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = .45) +
        geom_line(alpha = 0.3)
      
      p_points_final <- FuncPlotEnd(p = p_points) +
        facet_wrap(RSS ~ NumerLevel, labeller = label_wrap_gen(multi_line=FALSE), ncol = 1)
      p_points_list[[v]] <- p_points_final
    }
  }

  # One_loc_many_sub
  if (sel_splitplot == "one_loc_many_sub") {
    # assign colors
    color_levels <- sort(unique(plot_dat$NumerLevel)) # levels to be assigned colors
    cbp1_assigned <- switch((length(color_levels) <= length(cbp1)) + 1,  colorRampPalette(cbp1)(length(color_levels)), cbp1[1:length(color_levels)])
    
    for(v in sort(unique(plot_dat$RSS))) {
      dat_df <- plot_dat %>%
        dplyr::filter(RSS == v)
      
      p_points <-
        ggplot(data = dat_df, aes(x = SurvDate, y = y_val, N = N, CI_low = CI_low, CI_high = CI_high)) +
        labs(x = "Year", y = y_text) +
        geom_point(aes(color = NumerLevel, text = paste0("Reporting Site: ", ReportingSite, "<br>Site: ", Site, "<br>Survey Date: ", SurvDate, "<br>N: ", N, "<br>% Cover: ", y_val, "<br>CI low end: ", CI_low, "<br>CI high end: ", CI_high)), size = 2) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works
        geom_errorbar(aes(ymin = CI_low, ymax = CI_high, color = NumerLevel), width = .45) +
        geom_line(aes(color = NumerLevel), alpha = 0.3)
      
      if(PC_blackwhite) {
        p_points <- p_points + scale_colour_grey()
      } else {
        p_points <- p_points +
          scale_color_manual(limits = color_levels, values = cbp1_assigned, na.value = "black", drop = FALSE) # specifying all possible values in limits is required to make sure they are not dropped from legend when not in data
      }
 
      p_points_final <- FuncPlotEnd(p = p_points) +
        facet_wrap(. ~ RSS, ncol = 1)
      p_points_list[[v]] <- p_points_final
    }
  }
  
  # One_sub_many_loc
  if (sel_splitplot == "one_sub_many_loc") {
    # assign colors
    color_levels <- sort(unique(plot_dat$RSS)) # levels to be assigned colors
    cbp1_assigned <- switch((length(color_levels) <= length(cbp1)) + 1,  colorRampPalette(cbp1)(length(color_levels)), cbp1[1:length(color_levels)])
    
    for(v in sort(unique(plot_dat$NumerLevel))) {
      dat_df <- plot_dat %>%
        dplyr::filter(NumerLevel == v)
      
      p_points <-
        ggplot(data = dat_df, aes(x = SurvDate, y = y_val)) +
        labs(x = "Year", y = y_text) + 
        geom_point(aes(color = RSS, text = paste0("Reporting Site: ", ReportingSite, "<br>Site: ", Site, "<br>Survey Date: ", SurvDate, "<br>N: ", N, "<br>% Cover: ", y_val, "<br>CI low end: ", CI_low, "<br>CI high end: ", CI_high)), size = 2) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works
        geom_errorbar(aes(ymin = CI_low, ymax = CI_high, color = RSS), width = .45) +
        geom_line(aes(color = RSS), alpha = 0.3)
        
      
      if(PC_blackwhite) {
        p_points <- p_points + scale_colour_grey()
      } else {
        p_points <- p_points +
          scale_color_manual(limits = color_levels, values = cbp1_assigned, na.value = "black", drop = FALSE) # specifying all possible values in limits is required to make sure they are not dropped from legend when not in data
      }
      
      p_points_final <- FuncPlotEnd(p = p_points) +
        facet_wrap(. ~ NumerLevel, ncol = 1)
      p_points_list[[v]] <- p_points_final
    }
  }
 
  return(p1_points_list)
}
```

```{r action_button_import_new_data}
observeEvent(eventExpr = input$button_import, {
  if(is.null(input$filenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No coral data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$filenam$datapath), message = FALSE))
  
  if(is.null(input$sitesfilenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No sites data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$sitesfilenam$datapath), message = FALSE))
                
  withProgress(message = "Please be patient. Calculating something wonderful...", value = 0, {
    FuncCorals(filenam = input$filenam$datapath, sitesfilenam = input$sitesfilenam$datapath, out_prefix = input$out_prefix)
    
    rv_param_temp <- reactiveValues(dat_PC = NULL, avail_sublevs = NULL, sel_showRSS = NULL, sel_sublev = NULL)
    
     showModal(modalDialog(
        title = "Done",
        paste0("A summary RDS file has been saved as '", input$out_prefix, ".RDS' in the current working directory, ", getwd(), ". You may now select it for viewing (use the input box below, titled 'Select a summary RDS file')")
      ))
    })
})
```

```{r action_load_RDS}
observeEvent(eventExpr = input$summaryfile, {
  out <- readRDS(input$summaryfile$datapath)
  shiny::validate(need(names(out) == names(rv), message = paste0("DATA PROCESSING ERROR: The loaded file needs to have these and only these list elements: ", paste(names(rv), collapse = ", "), ". Please try with another file.")))
 
  rv <- sapply(names(out), FUN = function(i) {rv[[i]] <- out[[i]]}, simplify = FALSE)
  
  rv_param_temp <- reactiveValues(dat_PC = NULL, avail_sublevs = NULL, sel_showRSS = NULL, sel_sublev = NULL)
  
  Sys.sleep(0.25)
  
  showModal(modalDialog(
  title = "Done",
  "You may now navigate to the other tabs for summary graphs and tables"
  ))
})
```

```{r action_buttons_select_sublevels}
observeEvent(eventExpr = input$sublev_all_button, {
  shiny::req(!is.null(rv_param_temp$avail_sublevs))
  updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$avail_sublevs, selected = rv_param_temp$avail_sublevs)
  })

observeEvent(eventExpr = input$sublev_none_button, {
  shiny::req(!is.null(rv_param_temp$avail_sublevs))
  updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$avail_sublevs, selected = character(0))
  })

observeEvent(eventExpr = input$sublev_esa_button, {
  shiny::req(!is.null(rv_param_temp$avail_sublevs), !is.null(input$sel_lev))
  if(input$sel_lev == "Taxon") {
    updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$avail_sublevs, selected = intersect(c("ACER", "APAL", "DCYL", "OANN", "OFAV", "OFRA"), rv_param_temp$avail_sublevs)) # select all ESA taxa that are among the available sublevels
  } else { # The ESA button should only show when grouping level is 'Taxon', but including this 'else' just in case
    showModal(modalDialog(
      title = "ESA not available",
    "This option is only available when selected grouping level is 'Taxon'."
    ))
  }
  })
```

```{r action_button_export_PC}
observeEvent(eventExpr = input$button_export_PC, {
  shiny::req(!is.null(rv_param_temp$dat_PC))
    dat_export <- rv_param_temp$dat_PC 
    colnames(dat_export)[colnames(dat_export)=="y_val"] <- "Mean"
    colnames(dat_export)[colnames(dat_export)=="y_low"] <- paste0(input$sel_error, "_low")
    colnames(dat_export)[colnames(dat_export)=="y_high"] <- paste0(input$sel_error, "_high")
  
    write.csv(dat_export, "corals_perccov.csv", row.names = FALSE)
    showModal(modalDialog(
    title = "Done",
    paste0("The data have been saved as corals_perccov.csv in the current working directory, ", getwd())
    )
    )
})
```

```{r action_button_update_cover}
# Action to update cover summaries with current user inputs
observeEvent(eventExpr = input$button_update_cover, {

  shiny::req(!is.null(rv$cover_CIs_df), !is.null(input$sel_lev), !is.null(input$sel_sitescale), !is.null(input$sel_sublev), !is.null(input$sel_showRSS), !is.null(input$sel_episodic), !is.null(input$sel_splitplot))
 
  dat_PC <- rv$cover_CIs_df %>%
    dplyr::filter(
      SiteScale == input$sel_sitescale,
      RSS %in% input$sel_showRSS,
      NumerGroup == input$sel_lev,
      NumerLevel %in% input$sel_sublev
      )
 
  if(input$sel_episodic == FALSE) # remove episodic data
    dat_PC %<>% filter(Purpose == "Annual") %>%
    dplyr::arrange(RSS, NumerLevel, SurvDate)
  
  rv_param_temp$dat_PC <- dat_PC
  rv_param_temp$sel_showRSS <- input$sel_showRSS # make sure user selection doesn't automatically update plot page height
  rv_param_temp$sel_sublev <- input$sel_sublev
  
  saveRDS(isolate(reactiveValuesToList(input)), "temp_input.RDS")
saveRDS(isolate(reactiveValuesToList(rv_param_temp)), "temp_rv_param_temp.RDS") # <<<<<<<<<<<<<<<<<<<<

  shinyjs::hideElement("wp_cover_criteria")
})
```

```{r export_cover_table}
observeEvent(eventExpr = input$rtf_button, {
  rtffile <- rtf::RTF(paste0(input$sel_tabsite, "_", input$sel_tabsurv, ".doc"), width = 11, height = 8.5, font.size = 10, omi = c(1, 0.5, 1, 0.5))
  rtf::addHeader(rtffile, title = paste0(input$sel_tabsite, " (", input$sel_tabsurv, ")"), subtitle = "Point Counts", font.size = 14)
  rtf::addTable(rtffile, data_point(), col.justify = "C", header.col.justify = "C", row.names = TRUE)
  rtf::addPageBreak(rtffile, width = 10, height = 8.5, omi = c(1, 0.5, 1, 0.5))
  rtf::addHeader(rtffile, title = paste0(input$sel_tabsite, " (", input$sel_tabsurv, ")"), subtitle = "% Cover", font.size = 14)
  rtf::addTable(rtffile, data_perccov(), col.justify = "C", header.col.justify = "C", row.names = TRUE)
  rtf::done(rtffile)
  showModal(modalDialog(
    title = "Done",
    paste0("The tables have been saved as ", input$sel_tabsite, "_", input$sel_tabsurv, ".doc in the current working directory, ", getwd())
  ))
})
```
  
Import
======================================

Column {data-width=10}
-------------------------------------

Column {data-width=525}
-------------------------------------
#### <font size="5"> Instructions for processing a raw data file (jump to Step 6 if you already have a summary RDS file)</font> 

<font size="4"> 

1.  Create a coral data CSV file that summarizes the coral data by transect with these required columns (case-sensitive): *BleachingCode, Category, CountOfTaxonCode, Date, FunctionalGroup, Latitude, Longitude, ParkCode, Purpose, Site, SubCategory, TaxonCode, Transect, TripName, Year*    

2.  Create a sites data CSV file that links reporting sites with sites and specifies if the sites are still active. The required colums are (case-sensitive): *ParkCode, Site, ReportingSite, ReportingSiteName, IsActive* (where "ReportingSiteName" is the full name corresponding with "ReportingSite", and "IsActive" = 1 for active sites and 0 for inactive sites)

3.  Enter a prefix to append to the output summary file.

4. Browse to and upload the coral and sites data files (CSV), then press the "Import and Process New Data" button.

5.  When data processing is completed, a summary data file will be output to the current working directory as an RDS with the name '(your prefix)_coralsummary.RDS'. PROCEED TO STEP #6 TO IMPORT THE NEWLY CREATED .RDS FILE.

</font> 

#### <font size="5"> Instructions for importing a summary RDS file</font> 

<font size="4"> 

6.  Browse to and import the '(your prefix)_coralsummary.RDS' file, to generate summaries in the plot and table tabs.

</font> 

Column {data-width=10}
-------------------------------------

Column {data-width=225}
-------------------------------------

### PROCESS A RAW CORAL DATA FILE {data-height=150}
```{r select_raw_data}
textInput("out_prefix", label = "Prefix to append to output files: ", value = paste0("corals", gsub(pattern = "-", replacement = "", x = Sys.Date()), "_"), width = "100%")

fileInput("filenam", label = "Select a coral survey CSV file (make sure you've entered a file Prefix!)", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

fileInput("sitesfilenam", label = "Select a sites CSV file", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

actionButton("button_import", "IMPORT AND PROCESS NEW DATA", width = "100%")
```

### IMPORT A CORAL SUMMARY FILE {data-height=100}
```{r select_files}
fileInput("summaryfile", label = "Select a summary RDS file", accept = c('.RDS'), width = "100%")
```

Data Warnings
====================================== 
Column
-------------------------------------
**SURVEY TRIPS WITH PURPOSE OTHER THAN "ANNUAL" OR "EPISODIC"**
*(These data are excluded from analyses)*
```{r warnings}

br()

renderTable({
  validate(need(!is.null(rv$warn_list), message = FALSE))
  AltPurp <- rv$warn_list$AltPurp
  validate(need(nrow(AltPurp) > 0, "No warnings to show"))
  AltPurp
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SURVEY TRIPS WITH MISSING TAXON CODES OR RECORDED AS "NO TAXON"**
```{r}
renderTable({
  validate(need(!is.null(rv$warn_list), message = FALSE))
  NoTaxon <- rv$warn_list$UNKTaxon
  validate(need(nrow(NoTaxon) > 0, "No warnings to show"))
  NoTaxon
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SURVEY TRIPS WITH BLEACHING CODES ASSIGNED TO NON-CORAL TRANSECT HITS**
*(These data are excluded from bleaching analyses)*
```{r}
renderTable({
  validate(need(!is.null(rv$warn_list), message = FALSE))
  BleachCode <- rv$warn_list$BleachCode
  validate(need(nrow(BleachCode) > 0, "No warnings to show"))
  BleachCode
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SITE-SURVEYS WITH TRANSECT COUNTS OTHER THAN 4 OR 20**
```{r}
renderTable({
  validate(need(!is.null(rv$warn_list), message = FALSE))
  TransCount <- rv$warn_list$TransCount
  validate(need(nrow(TransCount) > 0, "No warnings to show"))
  TransCount$`Survey Date` <- as.character(lubridate::ymd(TransCount$`Survey Date`)) # renderTable does not play nice with dates--need to format as character
  TransCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH TOTAL TAXON COUNTS NOT DIVISIBLE BY 10**
```{r}
renderTable({
  validate(need(!is.null(rv$warn_list), message = FALSE))
  TaxonCountDiv <- rv$warn_list$TaxonCountDiv
  validate(need(nrow(TaxonCountDiv) > 0, "No warnings to show"))
  TaxonCountDiv
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH TOTAL TAXON COUNTS LESS THAN 200 OR GREATER THAN 480**
```{r}
renderTable({
  validate(need(!is.null(rv$warn_list), message = FALSE))
  TaxonCount <- rv$warn_list$TaxonCount
  validate(need(nrow(TaxonCount) > 0, "No warnings to show"))
  TaxonCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH EQUIPMENT OR SHADOW HITS EXCEEDING 5% OF TOTAL TAXON COUNTS**
```{r}
renderTable({
  validate(need(!is.null(rv$warn_list), message = FALSE))
  EquipShadowCount <- rv$warn_list$EquipShadowCount
  validate(need(nrow(EquipShadowCount) > 0, "No warnings to show"))
  EquipShadowCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH UNKNOWN ("UNK") HITS EXCEEDING 5% OF TOTAL TAXON COUNTS**
```{r}
renderTable({
  validate(need(!is.null(rv$warn_list), message = FALSE))
  UNKCount <- rv$warn_list$UNKCount
  validate(need(nrow(UNKCount) > 0, "No warnings to show"))
  UNKCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

Raw Data
======================================  
Inputs {.sidebar data-width=275}
-------------------------------------
```{r input_raw}
```

Raw Data Plots
-------------------------------------
### Data by Transects

Raw Data Table
-------------------------------------
### Data Table

Cover Estimates
======================================  
Inputs {.sidebar data-width=275}
-------------------------------------
```{r input_cover_filter}
br()

strong("Data Filter Options")

# shinyjs::hidden( # initially hide this well panel
wellPanel(
  id = "wp_cover_criteria",
  
  actionButton("button_update_cover", "Update Cover Summaries", style="background-color:#66CD00; color:black;", width = "95%"),
  
  br(),

    # tags$div(renderText({ 
    #   shiny::req(!is.null(input$sel_error))
    #   if(input$sel_error == "SE") {
    #     paste0("WARNING!! SE is valid for % cover only if individual transect data are approximately normally distributed. SE error bars that extend below zero are one indication that SE calculations are not appropriate for your data.")  # Post a warning about using SE
    #     }
    #   }), style = "font-size:14px; color:red; font-weight:bold;"),
  
  # Pre-filter data
  checkboxInput("RSS_active", label = "Only use active sites", value = FALSE), #NOTE: Don't need switch() function to keep inputs from changing on these
  checkboxInput("sel_episodic", label = "Include episodic survey data", value = TRUE),
  
  # Select spatial scale--sites or reporting sites
  renderUI({
    radioButtons("sel_sitescale", 
             label = "Summarize data at this spatial scale:", 
             choiceNames = list("Reporting Site", "Site"),
             choiceValues = list("ReportingSite", "Site"),
             selected = switch(is.null(input$sel_sitescale)+1, input$sel_sitescale, "Site"),
             inline = TRUE)
    }),
  
  tags$div(renderText({
    shiny::req(!is.null(input$sel_sitescale))
    if(input$sel_sitescale == "ReportingSite") {
      paste0("NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites")  # Explain how reporting sites are summarized
      }
    }), style = "font-size:14px; color:red; font-weight:bold;"),
  
  renderUI({
    shiny::req(!is.null(rv$map_dat), !is.null(input$sel_sitescale), !is.null(input$RSS_active))
    
    RSS_choices <- rv$map_dat %>%
      dplyr::filter(if(input$RSS_active == TRUE) IsActive == 1 else TRUE) %>%
      {if(input$sel_sitescale == "Site") dplyr::select(., Site) else dplyr::select(., ReportingSite)} %>%
      dplyr::distinct() %>%
      pull() %>%
      as.character()
    
    # Select (reporting) sites
    checkboxGroupInput("sel_showRSS", 
                       label = paste0("Show results for these ", ifelse(input$sel_sitescale == "ReportingSite", "reporting sites", "sites")),
                       choices = RSS_choices, 
                       selected = if(!is.null(input$sel_showRSS) & all(input$sel_showRSS %in% RSS_choices)) {input$sel_showRSS} else {RSS_choices}, # if selections already made and they are a subset of RSS_choices, then use those selections; otherwise, use RSS_choices as default
                       inline = FALSE) 
    }),
  
  # Select numerator grouping scale for cover estimates
  renderUI({
    selectInput("sel_lev", 
                label = "Select grouping level", 
                choices = c("Category" = "Category", "Functional Group" = "FunctionalGroup", "Taxon" = "Taxon"),
                selected = switch(is.null(input$sel_lev)+1, input$sel_lev, "Category"))
    }),
  
  # If grouping option is finer than Category, then user must select a category to see the selection options for the finer grouping level
  
  renderUI({ # if estimating cover for a level other than Category, restrict summaries to a single Category
    shiny::req(!is.null(rv$cover_CIs_df), !is.null(input$sel_lev), !is.null(input$sel_showRSS))
    shiny::req(input$sel_lev != "Category")
    
    avail_categ <- sort(unique(rv$cover_CIs_df$Category[rv$cover_CIs_df$NumerGroup==input$sel_lev & rv$cover_CIs_df$RSS %in% input$sel_showRSS]))
    
    selectInput("sel_categ",
                label = paste0("Show ", input$sel_lev, " for this category"),
                choices = avail_categ,
                selected = switch(is.null(input$sel_categ)+1, input$sel_categ, "CORAL"))
    }),
  
  # Group levels to choose from (e.g., algae, coral...) for the selected grouping level. For Functional Group, only options are ALGAE and CORAL. For Taxon, options are ALGAE, CORAL, GORGO, SPONGE
  renderUI({
    shiny::req(!is.null(rv$groups_df), !is.null(input$sel_lev), !is.null(input$sel_sitescale), !is.null(input$sel_showRSS), !is.null(input$sel_episodic))
    
    rv_param_temp$avail_sublevs <- rv$cover_CIs_df %>%
      dplyr::filter(
        SiteScale == input$sel_sitescale,
        RSS %in% input$sel_showRSS,
      NumerGroup == input$sel_lev) %>%
      dplyr::filter(if(input$sel_lev != "Category" & !is.null(input$sel_categ)) Category == input$sel_categ else TRUE) %>%
      dplyr::filter(if(input$sel_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
      pull(NumerLevel) %>%
      as.character() %>%
      unique() %>%
      sort()
      
  # sublev_default <- ifelse("CORAL" %in% rv_param_temp$avail_sublevs, "CORAL", rv_param_temp$avail_sublevs[1])

  checkboxGroupInput("sel_sublev", 
                     label = "Select sublevel(s)",
                     choices = rv_param_temp$avail_sublevs, 
                     selected = if(!is.null(input$sel_sublev) & all(input$sel_sublev %in% rv_param_temp$avail_sublevs)) {input$sel_sublev} else {character(0)}, inline = TRUE)
  }),
  
  actionButton("sublev_all_button", "Select All", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  actionButton("sublev_none_button", "Select None", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  conditionalPanel(
    condition = "input.sel_lev == 'Taxon'",
    actionButton("sublev_esa_button", "Select ESA", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px")
    ), 

  br(),
  
  br(),
  
  actionButton("button_export_PC", "Click to Export Plot Data", width = "95%")
) # end of 'wp_cover_criteria'
```
 
```{r input_cover_format}

strong("Figure Format Options")

br()

renderUI({
  radioButtons("sel_error",
             label = "Bootstrapped error bars to plot",
             choiceNames = list("90%CI", "68%CI (~1SE)", "50%CI"),
             choiceValues = list("90%CI", "68%CI", "50%CI"),
             selected = switch(is.null(input$sel_error)+1, input$sel_error, "90%CI"),
             inline = TRUE)
})

renderUI({
  shiny::req(!is.null(input$sel_showRSS), !is.null(input$sel_sublev))

  selectInput("sel_splitplot", label = "In a single plot, show: ", choices = c("One sublevel, many locations" = "one_sub_many_loc", "One location, many sublevels" = "one_loc_many_sub", "One location, one sublevel" = "one_loc_one_sub"), selected = switch(is.null(input$sel_splitplot)+1, input$sel_splitplot, "one_sub_many_loc"), width = "95%")
})

renderUI({
  numericInput("sel_ncols",
             label = "Arrange plots in how many columns?",
             value = switch(is.null(input$sel_ncols)+1, input$sel_ncols, 1),
             min = 1,
             max = 3,
             step = 1)
})

renderUI({
  checkboxInput("PC_blackwhite", label = "Plot in grayscale (can only handle up to 6 categories)", value = switch(is.null(input$PC_blackwhite)+1, input$PC_blackwhite, FALSE))
})

renderUI({
  numericInput("PCy_max", label = "Set y-axis maximum", min = 5, max = 105, step = 5, value = switch(is.null(input$PCy_max)+1, input$PCy_max, NULL))
})

# numericInput("PCy_int", label = "Increment for y-axis ticks", min = 5, max = 100, step = 5, value = 10)

textInput("PCplot_title", "Enter text to use for plot title", value = "")
```

% Cover {.tabset .tabset-fade}
-------------------------------------
### % Cover Plots

```{r plot_PC}
output$out_cover_plot <- plotly::renderPlotly({
  
  shiny::validate(
    need(!is.null(rv_param_temp$dat_PC), message = "From 'Data Filter Options' on the left, please select filter criteria then press the green 'UPDATE COVER SUMMARIES' button"))
  
  shiny::req(!is.null(input$sel_splitplot), !is.null(input$PC_blackwhite), !is.null(input$sel_error), !is.null(rv_param_temp$sel_showRSS), !is.null(rv_param_temp$sel_sublev), !is.null(input$sel_ncols))
  
  cbp1 <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7", "#0072B2", "#D55E00", "#999999", "#F0E442", "#000000", "chocolate4", "purple4", "chartreuse", "lightpink", "honeydew2") # Colorblind-friendly palette
  
  cov_plot_dat <- rv_param_temp$dat_PC %>%
    dplyr::filter(DenomGroup == "TransectCount") %>% # percent cover of transect
    dplyr::rename(CI_low = contains(paste0(input$sel_error, "_low")),
                  CI_high = contains(paste0(input$sel_error, "_high")))
  
if(input$sel_splitplot == "one_loc_one_sub") { # one plot per loc-sub
  plotly_PC <- 
    ggplot(data = cov_plot_dat, aes(x = SurvDate, y = EstimCov, N = N, CI_low = CI_low, CI_high = CI_high), colour = "black")
  } else { # multiple colors in one plot
    
    # assign colors
    color_levels <- switch((input$sel_splitplot == "one_loc_many_sub")+1,  sort(unique(cov_plot_dat$RSS)), sort(unique(cov_plot_dat$NumerLevel))) # levels to be assigned colors
    cbp1_assigned <- switch((length(color_levels) <= length(cbp1)) + 1,  colorRampPalette(cbp1)(length(color_levels)), cbp1[1:length(color_levels)])
  
    plotly_PC <- 
      ggplot(data = cov_plot_dat, aes_string(x = "SurvDate", y = "EstimCov", colour = ifelse(input$sel_splitplot == "one_loc_many_sub", "NumerLevel", "RSS"), N = "N", CI_low = "CI_low", CI_high = "CI_high")) # additional aes arguments (e.g., CI_low) are for hover text
  
  if(input$PC_blackwhite) {
    plotly_PC <- plotly_PC + scale_colour_grey()
  } else {
    plotly_PC <- plotly_PC +
      scale_color_manual(values = cbp1_assigned)
  }
}
  
  plotly_PC <- plotly_PC +
    geom_point() +
    geom_line() +
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = .25)
  
  facet_vars <- switch(input$sel_splitplot,
                     "one_loc_one_sub" = "~ RSS + NumerLevel",
                     "one_loc_many_sub" = "~ RSS",
                     "one_sub_many_loc" = "~ NumerLevel")
  
  default_title <- paste0("% Cover (", input$sel_error, ")")
  plotly_PC2 <- plotly_PC +
    expand_limits(y = switch(is.null(input$PCy_max)+1, c(0, input$PCy_max, 0), 0)) +
    labs(x = "Year", y = paste0("Mean % Cover Per Transect (", input$sel_error, ")")) +
    scale_x_date(date_labels = "%Y", breaks = scales::pretty_breaks()) +
    facet_wrap(as.formula(facet_vars), scales = "free_y", ncol = input$sel_ncols) +
    theme_bw(base_size = 12) +
    theme(legend.title = element_blank())
#,panel.spacing = unit(2, "lines"))
  
  facet_ht <- 260
  add_on_ht <- 180 # this is for title and subtitle
  page_ht <- switch(input$sel_splitplot,
                     "one_loc_one_sub" = ceiling(length(rv_param_temp$sel_sublev) * length(rv_param_temp$sel_showRSS)/input$sel_ncols) * facet_ht + add_on_ht,
                     "one_loc_many_sub" = ceiling(length(rv_param_temp$sel_showRSS)/input$sel_ncols) * facet_ht + add_on_ht,
                     "one_sub_many_loc" = ceiling(length(rv_param_temp$sel_sublev)/input$sel_ncols) * facet_ht + add_on_ht
  )

  gp <- ggplotly(plotly_PC2,
                   height = page_ht,
                   tooltip = c("RSS", "SurvDate", "N", "y_val", "y_low", "y_high")) # specify the total plot height here because this layout will be applied to the entire page
  
#   # Code to fix the duplicate legend entry problem that occurs when ggplotly is used on faceted ggplot with a scale_colour... or scale_fill... argument
#   for (i in seq_along(gp$x$data)) {
#   # Is the layer the first entry of the group?
#   is_first <- grepl("^\\(.*?,1\\)", gp$x$data[[i]]$name)
#   # Extract the group identifier and assign it to the name and legendgroup arguments
#   gp$x$data[[i]]$name <- gsub("^\\((.*?),\\d+\\)", "\\1", gp$x$data[[i]]$name)
#   gp$x$data[[i]]$legendgroup <- gp$x$data[[i]]$name
#   # Show the legend only for the first layer of the group 
#   if (!is_first) gp$x$data[[i]]$showlegend <- FALSE
# }
  
  gp <- gp %>% layout(
    title = list( # axis and other plot titles from ggplot get lost in ggplotly, so specify it here
      text = paste(switch((nchar(input$PCplot_title)==0)+1, input$PCplot_title, default_title), "<br>", "<sup>", "(X-axis tick marks Jan. 1 of each year)", "</sup>"),
      xanchor = "center", yanchor = "bottom", x = 0.55, y = 0.96),
    legend = list(orientation = "h", xanchor = "center", yanchor = "bottom", y = 1.02, x = 0.5),
    # xaxis = list(title = "Year", automargin=TRUE), 
    # yaxis = list(title = paste0("Mean % Cover (", input$sel_error, ")"), automargin=TRUE),
    margin = list(
      t=120,
      b=70,
      l= 100,
      r=15))
  
  gp[['x']][['layout']][['annotations']][[2]][['x']] <- -0.10 # move y-axis title more to the left
  gp[['x']][['layout']][['annotations']][[1]][['y']] <- -0.06 # move x-axis title down more. This affects the x-axis title specified in ggplot
  
  gp
})

tags$style("#out_cover_plot{height:100vh;overflow-x:scroll;overflow-y:scroll}")
plotlyOutput("out_cover_plot")
```

### Relative % Cover Plots

```{r plot_RC}
output$out_RC_plot <- plotly::renderPlotly({
  
  shiny::validate(
    need(!is.null(rv_param_temp$dat_PC), message = "From 'Data Filter Options' on the left, please select filter criteria then press the green 'UPDATE COVER SUMMARIES' button"))
  
  shiny::req(!is.null(input$sel_splitplot), !is.null(input$PC_blackwhite), !is.null(input$sel_error), !is.null(rv_param_temp$sel_showRSS), !is.null(input$sel_lev), !is.null(rv_param_temp$sel_sublev), !is.null(input$sel_ncols))
  
  shiny::validate(
    need(input$sel_lev!="Category", message = "Relative % cover is estimated only when the grouping level is 'Functional Group' or 'Taxon'")
  )
  
  cbp1 <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7", "#0072B2", "#D55E00", "#999999", "#F0E442", "#000000", "chocolate4", "purple4", "chartreuse", "lightpink", "honeydew2") # Colorblind-friendly palette
  
  RC_plot_dat <- rv_param_temp$dat_PC %>%
    dplyr::filter(DenomGroup == "CategoryCount") %>% # relative % cover of category
    dplyr::rename(CI_low = contains(paste0(input$sel_error, "_low")),
                  CI_high = contains(paste0(input$sel_error, "_high")))
  
if(input$sel_splitplot == "one_loc_one_sub") { # one plot per loc-sub
  plotly_RC <- 
    ggplot(data = RC_plot_dat, aes(x = SurvDate, y = EstimCov, N = N, CI_low = CI_low, CI_high = CI_high), colour = "black")
  } else { # multiple colors in one plot
    
    # assign colors
    color_levels <- switch((input$sel_splitplot == "one_loc_many_sub")+1,  sort(unique(RC_plot_dat$RSS)), sort(unique(RC_plot_dat$NumerLevel))) # levels to be assigned colors
    cbp1_assigned <- switch((length(color_levels) <= length(cbp1)) + 1,  colorRampPalette(cbp1)(length(color_levels)), cbp1[1:length(color_levels)])
  
    plotly_RC <- 
      ggplot(data = RC_plot_dat, aes_string(x = "SurvDate", y = "EstimCov", colour = ifelse(input$sel_splitplot == "one_loc_many_sub", "NumerLevel", "RSS"), N = "N", CI_low = "CI_low", CI_high = "CI_high")) # additional aes arguments (e.g., CI_low) are for hover text
  
  if(input$PC_blackwhite) {
    plotly_RC <- plotly_RC + scale_colour_grey()
  } else {
    plotly_RC <- plotly_RC +
      scale_color_manual(values = cbp1_assigned)
  }
}
  
  plotly_RC <- plotly_RC +
    geom_point() +
    geom_line() +
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = .25)
  
  facet_vars <- switch(input$sel_splitplot,
                     "one_loc_one_sub" = "~ RSS + NumerLevel",
                     "one_loc_many_sub" = "~ RSS",
                     "one_sub_many_loc" = "~ NumerLevel")
  
  default_title <- paste0("Mean % Cover Per Transect (", input$sel_error, ")")
  plotly_RC2 <- plotly_RC +
    expand_limits(y = switch(is.null(input$PCy_max)+1, c(0, input$PCy_max, 0), 0)) +
    labs(x = "Year", y = paste0("Mean % Cover Per Transect (", input$sel_error, ")")) +
    scale_x_date(date_labels = "%Y", breaks = scales::pretty_breaks()) +
    facet_wrap(as.formula(facet_vars), scales = "free_y") +
    theme_bw(base_size = 12) +
    theme(legend.title = element_blank())
#,panel.spacing = unit(2, "lines"))
  
  facet_ht <- 260
  add_on_ht <- 180 # this is for title and subtitle
  page_ht <- switch(input$sel_splitplot,
                     "one_loc_one_sub" = ceiling(length(rv_param_temp$sel_sublev) * length(rv_param_temp$sel_showRSS)/input$sel_ncols) * facet_ht + add_on_ht,
                     "one_loc_many_sub" = ceiling(length(rv_param_temp$sel_showRSS)/input$sel_ncols) * facet_ht + add_on_ht,
                     "one_sub_many_loc" = ceiling(length(rv_param_temp$sel_sublev)/input$sel_ncols) * facet_ht + add_on_ht
  )

  gp <- ggplotly(plotly_RC2,
                   height = page_ht,
                   tooltip = c("RSS", "SurvDate", "N", "EstimCov", "CI_low", "CI_high")) # specify the total plot height here because this layout will be applied to the entire page
  
#   # Code to fix the duplicate legend entry problem that occurs when ggplotly is used on faceted ggplot with a scale_colour... or scale_fill... argument
#   for (i in seq_along(gp$x$data)) {
#   # Is the layer the first entry of the group?
#   is_first <- grepl("^\\(.*?,1\\)", gp$x$data[[i]]$name)
#   # Extract the group identifier and assign it to the name and legendgroup arguments
#   gp$x$data[[i]]$name <- gsub("^\\((.*?),\\d+\\)", "\\1", gp$x$data[[i]]$name)
#   gp$x$data[[i]]$legendgroup <- gp$x$data[[i]]$name
#   # Show the legend only for the first layer of the group 
#   if (!is_first) gp$x$data[[i]]$showlegend <- FALSE
# }
  
  gp <- gp %>% layout(
    title = list( # axis and other plot titles from ggplot get lost in ggplotly, so specify it here
      text = paste(switch((nchar(input$PCplot_title)==0)+1, input$PCplot_title, default_title), "<br>", "<sup>", "(X-axis tick marks Jan. 1 of each year)", "</sup>"),
      xanchor = "center", yanchor = "bottom", x = 0.55, y = 0.96),
    legend = list(orientation = "h", xanchor = "center", yanchor = "bottom", y = 1.06, x = 0.5),
    # xaxis = list(title = "Year", automargin=TRUE), 
    # yaxis = list(title = paste0("Mean % Cover (", input$sel_error, ")"), automargin=TRUE),
    margin = list(
      t=120,
      b=70,
      l= 100,
      r=15))
  
  gp[['x']][['layout']][['annotations']][[2]][['x']] <- -0.10 # move y-axis title more to the left
  gp[['x']][['layout']][['annotations']][[1]][['y']] <- -0.06 # move x-axis title down more. This affects the x-axis title specified in ggplot
  
  gp
})

tags$style("#out_RC_plot{height:100vh;overflow-x:scroll;overflow-y:scroll}")
plotlyOutput("out_RC_plot")
```