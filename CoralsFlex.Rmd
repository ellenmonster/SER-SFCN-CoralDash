---
title: "SFCN Coral Reefs"
output:
  flexdashboard::flex_dashboard:
    vertical_layout: scroll
    orientation: columns
    theme: sandstone   # theme options: default, cosmo, bootstrap, cerulean, journal, flatly, readable, spacelab, united, lumen, paper, sandstone, simplex, yeti
    css: custom_styles.css
runtime: shiny
---

```{r global, include=FALSE}

rm(list=ls())

### Load libraries -----
# Will automatically install any packages it can't find

pkgList <- c("flexdashboard", "shiny", "knitr", "gridExtra", "shinyWidgets", "leaflet", "plotly", "DT", "rtf", "lubridate", "leaflet.minicharts", "tidyverse", "magrittr", "htmlwidgets", "RSQLite", "multidplyr", "Rcpp", "reactable", "scales")
inst <- pkgList %in% installed.packages()
if (length(pkgList[!inst]) > 0) {install.packages(pkgList[!inst],dep=TRUE)}
lapply(pkgList, library, character.only = TRUE)

options(shiny.maxRequestSize = 20*1024^2) # allows data files up to 20 MB to be imported
source("Corals.R")

rv <- reactiveValues(raw_dat = NULL, map_dat = NULL, groups_df = NULL, warn_list = NULL, transect_counts_df = NULL, cover_CIs_df = NULL, bleach_CIs_df = NULL, disease_df = NULL, colcounts_df = NULL)

rv_param_temp <- reactiveValues(cover_subdat = data.frame(), avail_sublevs = NULL, sel_showRSS = NULL, sel_lev = NULL, sel_sublev = NULL, avail_diseases = NULL, transects_subdat = data.frame(), bleach_subdat = data.frame(), disease_prev_transect = data.frame(), disease_prev_site = data.frame())

### Load test data <<<<< THIS IS JUST FOR TESTING
  # rv <- readRDS("~/NPS PROJECTS_CURRENT/Dash_SFCN corals/temp_coralsummary.RDS")
```

```{r functions}
FuncWarnTable <-function(colnam) {
  validate(need(!is.null(rv$warn_list), message = FALSE))
  x_tab <- rv$warn_list[[colnam]]
  validate(need(nrow(x_tab) > 0, "No warnings to show"))
  return(x_tab)
}

FuncPlotPointCI <- function(dat, denom, sel_error, sel_splitplot, free_ymax, y_text, PC_blackwhite) {
  # Function to generate point plots with error bars
  #
  # Args:
  #   CI_dat:  The CI data frame
  #   denom: "TransectCount" for % cover or "CategoryCount" for relative cover
  #   combine_stations:  TRUE to combine multiple stations in a single plot of a characteristic
  #   fixed_free_y:  Are scales fixed or free across all plots?
  #
  # Returns:
  #   List of point plots with error bars
  # 
  
  # Colorblind-friendly palette
  cbp1 <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7", "#0072B2", "#D55E00", "#999999", "#F0E442", "#000000", "chocolate4", "purple4", "chartreuse", "lightpink", "honeydew2") 
  
  # Set up the data
  plot_dat <- dat %>%
    dplyr::filter(DenomGroup == denom) %>% 
    dplyr::rename(
      CI_low = contains(paste0(sel_error, "_low")),
      CI_high = contains(paste0(sel_error, "_high")))
  
  if(sel_splitplot == "one_loc_one_sub") { # one plot per loc-sub
    p <- 
      ggplot(data = plot_dat, aes(x = SurvDate, y = EstimCov), colour = "black")
  } else { # multiple colors in one plot
    
    # assign colors
    color_levels <- switch((sel_splitplot == "one_loc_many_sub")+1,  sort(unique(plot_dat$RSS)), sort(unique(plot_dat$NumerLevel))) # levels to be assigned colors
    cbp1_assigned <- switch((length(color_levels) <= length(cbp1)) + 1,  colorRampPalette(cbp1)(length(color_levels)), cbp1[1:length(color_levels)])
   
    p <- 
      ggplot(data = plot_dat, aes_string(x = "SurvDate", y = "EstimCov", colour = if_else(sel_splitplot == "one_loc_many_sub", "NumerLevel", "RSS"))) 
    
    if(PC_blackwhite) {
      p <- p + scale_colour_grey()
    } else {
      p <- p +
        scale_color_manual(values = cbp1_assigned)
    }
  }
  
  p <- p +
    geom_point(aes(text = paste0("Reporting Site: ", RSS, "<br>Site: ", Site, "<br>Survey Date: ", SurvDate, "<br># of Samples: ", N, "<br>% Cover: ", EstimCov, "<br>Lower CI: ", CI_low, "<br>Upper CI: ", CI_high))) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works
    geom_line() +
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = .25)
  
  facet_vars <- switch(sel_splitplot,
                       "one_loc_one_sub" = "~ RSS + NumerLevel",
                       "one_loc_many_sub" = "~ RSS",
                       "one_sub_many_loc" = "~ NumerLevel")
  
  p <- p +
    # expand_limits(y = switch(is.null(PCy_max)+1, c(0, PCy_max, 0), 0)) +
    expand_limits(y = c(0, 1)) + # y-axes must include 1
    labs(x = "Year", y = y_text) +
    scale_x_date(date_labels = "%Y", breaks = scales::pretty_breaks()) +
    facet_wrap(as.formula(facet_vars), scales = if_else(free_ymax, "free_y", "fixed"), ncol = 1) +
    theme_bw(base_size = 12) +
    theme(legend.title = element_blank())
  
  facet_ht <- 215
  add_on_ht <- 180 # this is for legend
  page_ht <- switch(sel_splitplot,
                    "one_loc_one_sub" = length(rv_param_temp$sel_sublev) * length(rv_param_temp$sel_showRSS) * facet_ht + add_on_ht,
                    "one_loc_many_sub" = length(rv_param_temp$sel_showRSS) * facet_ht + add_on_ht,
                    "one_sub_many_loc" = length(rv_param_temp$sel_sublev) * facet_ht + add_on_ht)

  gp <- ggplotly(p,
                 height = page_ht) # specify the total plot height here because this layout will be applied to the entire page
  
  gp <- gp %>% layout(
    legend = list(orientation = "h", xanchor = "center", yanchor = "bottom", y = 1.03, x = 0.5),
    margin = list(
      t=120,
      b=70,
      l= 100,
      r=15))
  
  gp[['x']][['layout']][['annotations']][[2]][['x']] <- -0.12 # move y-axis title more to the left
  gp[['x']][['layout']][['annotations']][[1]][['y']] <- -0.02 # move x-axis title down more. This affects the x-axis title specified in ggplot
  
  return(gp)
}

FuncPlotBleach <- function(dat, yaxis_title) {
  ggplot(dat, aes(x = SurvDate, y = EstimCov, fill = NumerLevel)) +
    geom_col(colour="black", size = 0.1, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = c("NoData" = "yellow", "UNBL" = "gray25", "BL1" = "gray45", "BL2" = "gray55", "BL3" = "gray75", "BL4" = "gray92")) +
    scale_y_continuous(expand = c(0, 0)) +
    labs(y = yaxis_title, subtitle = "For surveys from Oct. 2005 to present, coral data with NA entry for 'Bleaching Code' are considered 'Unbleached' (UNBL)") +
    theme_bw(base_size = 12) +
    facet_grid(. ~ Year, scales = "free_x", switch = "x") +
    theme(legend.title = element_blank(),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
          strip.text.x = element_text(size = 11),
          strip.background=element_blank(),
          panel.border = element_blank(),
          panel.grid = element_blank(),
          panel.spacing = unit(-0.05, "lines"))
}

FuncPlotDiseaseSite <- function(dat, y_col, yaxis_title, subtitle_text) {
  ggplot(dat, aes_string(x = "SurvDate", y = y_col, fill = "DiseaseStatus")) +
    geom_col(colour="black", size = 0.1, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = c("Diseased" = "red", "NotDiseased" = "black", "Unknown" = "yellow")) +
    # scale_y_continuous(expand = c(0, 0)) +
    labs(y = yaxis_title, subtitle = subtitle_text) +
    theme_bw(base_size = 12) +
    facet_grid(. ~ Year, scales = "free_x", switch = "x") +
    theme(legend.title = element_blank(),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
          strip.text.x = element_text(size = 11),
          strip.background=element_blank(),
          panel.border = element_blank(),
          panel.grid = element_blank(),
          panel.spacing = unit(-0.05, "lines"))
}
```

```{r action_button_import_new_data}
observeEvent(eventExpr = input$button_import, {
  if(is.null(input$filenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No coral data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$filenam$datapath), message = FALSE))
  
  if(is.null(input$sitesfilenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No sites data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$sitesfilenam$datapath), message = FALSE))
  
  if(is.null(input$diseasefilenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No disease data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$diseasefilenam$datapath), message = FALSE))
  
  if(is.null(input$colcountsfilenam$datapath))
    {showModal(modalDialog(title = "Aaaack! No colony count data selected!  Please select a file and try again"))}
  validate(need(!is.null(input$colcountsfilenam$datapath), message = FALSE))
  
  withProgress(message = "Please be patient. Calculating something wonderful...", value = 0, {
    FuncCorals(filenam = input$filenam$datapath, sitesfilenam = input$sitesfilenam$datapath, diseasefilenam = input$diseasefilenam$datapath, colcountsfilenam = input$colcountsfilenam$datapath, out_prefix = input$out_prefix)
    
    rv_param_temp <- reactiveValues(cover_subdat = data.frame(), avail_sublevs = NULL, sel_showRSS = NULL, sel_lev = NULL, sel_sublev = NULL, avail_diseases = NULL, transects_subdat = data.frame(), bleach_subdat = data.frame(), disease_prev_transect = data.frame(), disease_prev_site = data.frame())
    
     showModal(modalDialog(
        title = "Done",
        paste0("A summary RDS file has been saved as '", input$out_prefix, ".RDS' in the current working directory, ", getwd(), ". You may now select it for viewing (use the input box below, titled 'Select a summary RDS file')")
      ))
    })
})
```

```{r action_load_RDS}
observeEvent(eventExpr = input$summaryfile, {
  tryCatch(out <- readRDS(input$summaryfile$datapath),
             error = function(e) {out_file <- NULL; print("Cannot import the selected file")})
  
  shiny::validate(need(names(out) == names(rv), message = paste0("DATA PROCESSING ERROR: The loaded file needs to have these and only these list elements: ", paste(names(rv), collapse = ", "), ". Please try with another file.")))
 
  rv <- sapply(names(out), FUN = function(i) {rv[[i]] <- out[[i]]}, simplify = FALSE)
  
  rv_param_temp <- reactiveValues(cover_subdat = data.frame(), avail_sublevs = NULL, sel_showRSS = NULL, sel_lev = NULL, sel_sublev = NULL, avail_diseases = NULL, transects_subdat = data.frame(), bleach_subdat = data.frame(), disease_prev_transect = data.frame(), disease_prev_site = data.frame())

  Sys.sleep(0.25)
  
  showModal(modalDialog(
  title = "Done",
  "You may now navigate to the other tabs for summary graphs and tables"
  ))
})
```

```{r action_buttons_select_sublevels}
observeEvent(eventExpr = input$sublev_all_button, {
  shiny::req(!is.null(rv_param_temp$avail_sublevs))
  updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$avail_sublevs, selected = rv_param_temp$avail_sublevs)
  })

observeEvent(eventExpr = input$sublev_none_button, {
  shiny::req(!is.null(rv_param_temp$avail_sublevs))
  updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$avail_sublevs, selected = character(0))
  })

observeEvent(eventExpr = input$sublev_esa_button, {
  shiny::req(!is.null(rv_param_temp$avail_sublevs), !is.null(input$sel_lev))
  if(input$sel_lev == "Taxon") {
    updateCheckboxGroupInput(session, "sel_sublev", label = "Select sublevel(s)", choices = rv_param_temp$avail_sublevs, selected = intersect(c("ACER", "APAL", "DCYL", "OANN", "OFAV", "OFRA"), rv_param_temp$avail_sublevs)) # select all ESA taxa that are among the available sublevels
  } else { # The ESA button should only show when grouping level is 'Taxon', but including this 'else' just in case
    showModal(modalDialog(
      title = "ESA not available",
    "This option is only available when selected grouping level is 'Taxon'."
    ))
  }
  })
```

```{r action_button_export_PC}
observeEvent(eventExpr = input$button_export_PC, {
  shiny::req(!is.null(rv_param_temp$cover_subdat))
    dat_export <- rv_param_temp$cover_subdat 
    colnames(dat_export)[colnames(dat_export)=="y_val"] <- "Mean"
    colnames(dat_export)[colnames(dat_export)=="y_low"] <- paste0(input$sel_error, "_low")
    colnames(dat_export)[colnames(dat_export)=="y_high"] <- paste0(input$sel_error, "_high")
  
    write.csv(dat_export, "corals_perccov.csv", row.names = FALSE)
    showModal(modalDialog(
    title = "Done",
    paste0("The data have been saved as corals_perccov.csv in the current working directory, ", getwd())
    )
    )
})
```

```{r action_button_update_cover}
# Action to update cover summaries with current user inputs
observeEvent(eventExpr = input$button_update_cover, {

  shiny::req(!is.null(rv$cover_CIs_df), !is.null(input$sel_lev), !is.null(input$sel_sitescale), !is.null(input$sel_showRSS), !is.null(input$sel_episodic), !is.null(input$PC_blackwhite), !is.null(input$sel_error), !is.null(input$sel_splitplot))
  
  if(input$sel_lev != "Category") {shiny::validate(need(!is.null(input$sel_sublev), message = "Please select at least one sublevel, then press the green 'UPDATE COVER SUMMARIES' button"))}
 
  cover_subdat <- rv$cover_CIs_df %>%
    dplyr::filter(
      RSS %in% input$sel_showRSS,
      NumerGroup == input$sel_lev,
      NumerLevel %in% input$sel_sublev
      )
 
  if(input$sel_episodic == FALSE) { # remove episodic data
    cover_subdat %<>% filter(Purpose == "Annual") %>%
    dplyr::arrange(RSS, NumerLevel, SurvDate)}
  
  rv_param_temp$cover_subdat <- cover_subdat
  rv_param_temp$sel_showRSS <- input$sel_showRSS # make sure user selection doesn't automatically update plot page height
  rv_param_temp$sel_lev <- input$sel_lev
  rv_param_temp$sel_sublev <- input$sel_sublev

  shinyjs::hideElement("wp_cover_criteria")
})
```

```{r export_cover_table}
observeEvent(eventExpr = input$rtf_button, {
  rtffile <- rtf::RTF(paste0(input$sel_tabsite, "_", input$sel_tabsurv, ".doc"), width = 11, height = 8.5, font.size = 10, omi = c(1, 0.5, 1, 0.5))
  rtf::addHeader(rtffile, title = paste0(input$sel_tabsite, " (", input$sel_tabsurv, ")"), subtitle = "Point Counts", font.size = 14)
  rtf::addTable(rtffile, data_point(), col.justify = "C", header.col.justify = "C", row.names = TRUE)
  rtf::addPageBreak(rtffile, width = 10, height = 8.5, omi = c(1, 0.5, 1, 0.5))
  rtf::addHeader(rtffile, title = paste0(input$sel_tabsite, " (", input$sel_tabsurv, ")"), subtitle = "% Cover", font.size = 14)
  rtf::addTable(rtffile, data_perccov(), col.justify = "C", header.col.justify = "C", row.names = TRUE)
  rtf::done(rtffile)
  showModal(modalDialog(
    title = "Done",
    paste0("The tables have been saved as ", input$sel_tabsite, "_", input$sel_tabsurv, ".doc in the current working directory, ", getwd())
  ))
})
```
 
```{r action_buttons_select_diseases}
observeEvent(eventExpr = input$disease_all_button, {
  shiny::req(!is.null(rv_param_temp$avail_diseases))
  updateCheckboxGroupInput(session, "sel_diseases", label = "Select disease(s)", choices = rv_param_temp$avail_diseases, selected = rv_param_temp$avail_diseases)
  })

observeEvent(eventExpr = input$disease_none_button, {
  shiny::req(!is.null(rv_param_temp$avail_diseases))
  updateCheckboxGroupInput(session, "sel_diseases", label = "Select disease(s)", choices = rv_param_temp$avail_diseases, selected = character(0))
  })

observeEvent(eventExpr = input$disease_tissue_loss_button, {
  shiny::req(!is.null(rv_param_temp$avail_diseases))
    updateCheckboxGroupInput(session, "sel_diseases", label = "Select disease(s)", choices = rv_param_temp$avail_diseases, selected = intersect(c("BB", "SCTLD", "WB", "WPL", "WPX"), rv_param_temp$avail_diseases)) # select all tissue loss diseases that are among the available diseases
    })

observeEvent(eventExpr = input$disease_discoloration_button, {
  shiny::req(!is.null(rv_param_temp$avail_diseases))
    updateCheckboxGroupInput(session, "sel_diseases", label = "Select disease(s)", choices = rv_param_temp$avail_diseases, selected = intersect(c("DS", "YB"), rv_param_temp$avail_diseases)) # select all discoloration diseases that are among the available diseases
    })
``` 

```{r action_button_update_disease}
# Action to update disease summaries with current user inputs
observeEvent(eventExpr = input$button_update_disease, {

  shiny::req(!is.null(rv$disease_df), !is.null(rv$colcounts_df), !is.null(input$sel_disease_sitescale), !is.null(input$sel_disease_showRSS), !is.null(input$sel_disease_episodic), !is.null(input$sel_diseases))
 
  diseases <- rv$disease_df %>%
    dplyr::rename(RSS = input$sel_disease_sitescale) %>%
    dplyr::mutate(DiseaseFull = paste0(DiseaseDescription, " (", DiseaseCode, ")"),
                  TaxonFull = paste0(CoralScientificName, " (", Taxon, ")")) %>%
    dplyr::filter(
      RSS %in% input$sel_disease_showRSS,
      DiseaseCode %in% input$sel_diseases)
 
  # Remove episodic data
  if(input$sel_disease_episodic == FALSE) { 
    diseases %<>% filter(Purpose == "Annual")
  }
  
  # Filter colony counts data for the user-specified site
   master_counts <- rv$colcounts_df %>%
     dplyr::rename(RSS = input$sel_disease_sitescale) %>%
     dplyr::filter(RSS %in% input$sel_disease_showRSS) 
   
   # Disease data with associated colony numbers
   disease_cols_complete <- diseases %>%
     dplyr::select(TransectSurveyID, ColonyNumber, DiseaseFull, TaxonFull) %>%
     dplyr::filter(complete.cases(.))
   
   # Transect-level disease counts and prevalence, per survey event
   disease_prev_transect <- disease_cols_complete %>%
     dplyr::select(TransectSurveyID, ColonyNumber) %>%
     dplyr::distinct() %>%
     dplyr::group_by(TransectSurveyID) %>%
     dplyr::summarize(TransectDiseased = n_distinct(ColonyNumber)) %>%
     dplyr::full_join(master_counts, by = "TransectSurveyID")
   
   disease_prev_transect$TransectDiseased[is.na(disease_prev_transect$TransectDiseased) & !is.na(disease_prev_transect$StonyCoralCount1)] <- 0 # if there is a non-NA StonyCoralCount1, convert any NA disease count to zero
   disease_prev_transect %<>%
     dplyr::mutate(
       Year = lubridate::year(SurvDate),
       TransectNotDiseased = StonyCoralCount1 - TransectDiseased,
       TransectPrev = TransectDiseased / StonyCoralCount1
       ) %>%
     ungroup()
   
   # Site-level disease counts and prevalence (summed across transects for a survey event)
   disease_prev_site <- disease_prev_transect %>%
     dplyr::select(-TransectSurveyID, -Transect) %>%
     dplyr::group_by(across(c(-TransectDiseased, -TransectNotDiseased, -StonyCoralCount1, -StonyCoralCount2, -FireCoralCount1, -FireCoralCount2, -TransectPrev))) %>%
     dplyr::summarize(
       SiteDiseased = sum(TransectDiseased),
       SiteNotDiseased = sum(TransectNotDiseased),
       SiteCoralCount1 = sum(StonyCoralCount1),
       SiteCoralCount2 = sum(StonyCoralCount2),
       SiteFireCoralCount1 = sum(FireCoralCount1),
       SiteFireCoralCount2 = sum(FireCoralCount2),
       SitePrev = round(SiteDiseased / SiteCoralCount1, 3), 
       ) %>% 
     ungroup()
   
   rv_param_temp$disease_prev_transect <- disease_prev_transect
   rv_param_temp$disease_prev_site <- disease_prev_site
   })
```

Import
======================================

Column {data-width=10}
-------------------------------------

Column {data-width=525}
-------------------------------------
#### <font size="5"> Instructions for processing a raw data file (jump to Step 6 if you already have a summary RDS file)</font> 

<font size="4"> 

1.  Create a coral data CSV file that summarizes the coral data by transect with these required columns (case-sensitive): *BleachingCode, Category, CountOfTaxonCode, Date, FunctionalGroup, Latitude, Longitude, ParkCode, Purpose, Site, SubCategory, TaxonCode, Transect, TripName, Year*    

2.  Create a sites data CSV file that links reporting sites with sites and specifies if the sites are still active. The required colums are (case-sensitive): *ParkCode, Site, ReportingSite, ReportingSiteName, IsActive* (where "ReportingSiteName" is the full name corresponding with "ReportingSite", and "IsActive" = 1 for active sites and 0 for inactive sites)

3.  Enter a prefix to append to the output summary file.

4. Browse to and upload the coral and sites data files (CSV), then press the "Import and Process New Data" button.

5.  When data processing is completed, a summary data file will be output to the current working directory as an RDS with the name '(your prefix)_coralsummary.RDS'. PROCEED TO STEP #6 TO IMPORT THE NEWLY CREATED .RDS FILE.

</font> 

#### <font size="5"> Instructions for importing a summary RDS file</font> 

<font size="4"> 

6.  Browse to and import the '(your prefix)_coralsummary.RDS' file, to generate summaries in the plot and table tabs.

</font> 

Column {data-width=10}
-------------------------------------

Column {data-width=225}
-------------------------------------

### PROCESS A RAW CORAL DATA FILE {data-height=150}
```{r select_raw_data}
textInput("out_prefix", label = "Prefix to append to output files: ", value = paste0("corals", gsub(pattern = "-", replacement = "", x = Sys.Date()), "_"), width = "100%")

fileInput("filenam", label = "Select a coral survey CSV file (make sure you've entered a file Prefix!)", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

fileInput("sitesfilenam", label = "Select a sites CSV file", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

fileInput("diseasefilenam", label = "Select a disease CSV file", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

fileInput("colcountsfilenam", label = "Select a colony counts CSV file", accept = c('text/csv', 'text/comma-separated-values', '.csv'), width = "100%")

actionButton("button_import", "IMPORT AND PROCESS NEW DATA", width = "100%")
```

### IMPORT A CORAL SUMMARY FILE {data-height=100}
```{r select_files}
fileInput("summaryfile", label = "Select a summary RDS file", accept = c('.RDS'), width = "100%")
```

Data Warnings
====================================== 
Column
-------------------------------------
**PERCENT OF DATA CERTIFIED AS "ACCEPTED"**
*(All data are included regardless of certification level)*
```{r}
renderTable({
  FuncWarnTable(colnam = "CertLevel")
  # validate(need(!is.null(warn_list$CertLevel), message = FALSE))
  # rv$warn_list$CertLevel
  }, align = "c", na = "--", include.rownames = FALSE)
br()
``` 


**SURVEY TRIPS WITH PURPOSE OTHER THAN "ANNUAL" OR "EPISODIC"**
*(These data are excluded from analyses)*
```{r}
renderTable({
  FuncWarnTable(colnam = "AltPurp")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # AltPurp <- rv$warn_list$AltPurp
  # validate(need(nrow(AltPurp) > 0, "No warnings to show"))
  # AltPurp
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SURVEY TRIPS WITH MISSING TAXON CODES OR RECORDED AS "NO TAXON"**
```{r}
renderTable({
  FuncWarnTable(colnam = "UNKTaxon")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # NoTaxon <- rv$warn_list$UNKTaxon
  # validate(need(nrow(NoTaxon) > 0, "No warnings to show"))
  # NoTaxon
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SURVEY TRIPS WITH BLEACHING CODES ASSIGNED TO NON-CORAL TRANSECT HITS**
*(These data are excluded from bleaching analyses)*
```{r}
renderTable({
  FuncWarnTable(colnam = "BleachCode")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # BleachCode <- rv$warn_list$BleachCode
  # validate(need(nrow(BleachCode) > 0, "No warnings to show"))
  # BleachCode
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**SITE-SURVEYS WITH TRANSECT COUNTS OTHER THAN 4 OR 20**
```{r}
renderTable({
  validate(need(!is.null(rv$warn_list), message = FALSE))
  TransCount <- rv$warn_list$TransCount
  validate(need(nrow(TransCount) > 0, "No warnings to show"))
  TransCount$`Survey Date` <- as.character(lubridate::ymd(TransCount$`Survey Date`)) # renderTable does not play nice with dates--need to format as character
  TransCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH TOTAL TAXON COUNTS NOT DIVISIBLE BY 10**
```{r}
renderTable({
  FuncWarnTable(colnam = "TaxonCountDiv")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # TaxonCountDiv <- rv$warn_list$TaxonCountDiv
  # validate(need(nrow(TaxonCountDiv) > 0, "No warnings to show"))
  # TaxonCountDiv
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH TOTAL TAXON COUNTS LESS THAN 200 OR GREATER THAN 480**
```{r}
renderTable({
  FuncWarnTable(colnam = "TaxonCount")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # TaxonCount <- rv$warn_list$TaxonCount
  # validate(need(nrow(TaxonCount) > 0, "No warnings to show"))
  # TaxonCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH EQUIPMENT OR SHADOW HITS EXCEEDING 5% OF TOTAL TAXON COUNTS**
```{r}
renderTable({
  FuncWarnTable(colnam = "EquipShadowCount")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # EquipShadowCount <- rv$warn_list$EquipShadowCount
  # validate(need(nrow(EquipShadowCount) > 0, "No warnings to show"))
  # EquipShadowCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**TRANSECT SURVEYS WITH UNKNOWN ("UNK") HITS EXCEEDING 5% OF TOTAL TAXON COUNTS**
```{r}
renderTable({
  FuncWarnTable(colnam = "UNKCount")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # UNKCount <- rv$warn_list$UNKCount
  # validate(need(nrow(UNKCount) > 0, "No warnings to show"))
  # UNKCount
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**DISEASE RECORDS WITH UNKNOWN DISEASE CODE**
*(These data are excluded from analyses)*
```{r}
renderTable({
  FuncWarnTable(colnam = "UNKDisease")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # UNKDisease <- rv$warn_list$UNKDisease
  # validate(need(nrow(UNKDisease) > 0, "No warnings to show"))
  # UNKDisease
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**DISEASE RECORDS FOR COLONIES < 4CM**
*(These data are excluded from analyses)*
```{r}
renderTable({
  FuncWarnTable(colnam = "DiseaseColLT4CM")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # DiseaseColLT4CM <- rv$warn_list$DiseaseColLT4CM
  # validate(need(nrow(DiseaseColLT4CM) > 0, "No warnings to show"))
  # DiseaseColLT4CM
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**DISEASE SITE-TRANSECT-SURVEY DATES WITHOUT MATCHING CORAL VIDEO RECORDS**
*(These data are still presented in disease summaries)*
```{r}
renderTable({
  FuncWarnTable(colnam = "UnmatchedDiseaseID")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # UnmatchedDiseaseID <- rv$warn_list$UnmatchedDiseaseID
  # validate(need(nrow(UnmatchedDiseaseID) > 0, "No warnings to show"))
  # UnmatchedDiseaseID
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

**COLONY COUNTS SITE-TRANSECT-SURVEY DATES WITHOUT MATCHING CORAL VIDEO RECORDS**
*(These data are still presented in disease summaries, if corresponding disease data are available)*
```{r}
renderTable({
  FuncWarnTable(colnam = "UnmatchedColCountsID")
  # validate(need(!is.null(rv$warn_list), message = FALSE))
  # UnmatchedColCountsID <- rv$warn_list$UnmatchedColCountsID
  # validate(need(nrow(UnmatchedColCountsID) > 0, "No warnings to show"))
  # UnmatchedColCountsID
  }, align = "c", na = "--", include.rownames = FALSE)
br()
```

% Cover per Transect
======================================  
Inputs {.sidebar data-width=300}
-------------------------------------
```{r input_raw_filter}
br()

h4("Data Filter Options")

wellPanel(
  id = "wp_raw_criteria",

  # Pre-filter data
  checkboxInput("raw_RSS_active", label = "Only use active sites", value = FALSE), #NOTE: Don't need switch() function to keep inputs from changing on these
  checkboxInput("sel_raw_episodic", label = "Include episodic survey data", value = TRUE),
  
  # Select spatial scale--sites or reporting sites
  renderUI({
    radioButtons("sel_raw_sitescale", 
             label = "Show data for this spatial scale:", 
             choiceNames = list("Reporting Site", "Site"),
             choiceValues = list("ReportingSite", "Site"),
             selected = switch(is.null(input$sel_raw_sitescale)+1, input$sel_raw_sitescale, "Site"),
             inline = TRUE)
    }),
  
  tags$div(renderText({
    shiny::req(!is.null(input$sel_raw_sitescale))
    if(input$sel_raw_sitescale == "ReportingSite") {
      paste0("NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites")  # Explain how reporting sites are summarized
      }
    }), style = "font-size:14px; color:red; font-weight:bold;"),

  renderUI({
    shiny::req(!is.null(rv$raw_dat), !is.null(input$sel_raw_sitescale), !is.null(input$raw_RSS_active))
    
    raw_RSS_choices <- rv$raw_dat %>%
      dplyr::filter(if(input$raw_RSS_active == TRUE) IsActive == 1 else TRUE) %>%
      {if(input$sel_raw_sitescale == "Site") dplyr::pull(., Site) else dplyr::pull(., ReportingSite)} %>% unique(.)
    
    shiny::req(!is.null(raw_RSS_choices))
    
    # Select (reporting) site
    selectInput("sel_raw_showRSS", 
                       label = paste0("Show results for this ", if_else(input$sel_raw_sitescale == "ReportingSite", "reporting site", "site")),
                       choices = raw_RSS_choices, 
                       selected = switch(is.null(input$sel_raw_showRSS)+1, input$sel_raw_showRSS, raw_RSS_choices[1]))
    }),

  renderUI({
    shiny::req(!is.null(rv$raw_dat))
    
    selectInput("sel_raw_categ",
                label = paste0("Show transect counts for this category"),
                choices = sort(unique(rv$raw_dat$Category)),
                selected = switch(is.null(input$sel_raw_categ)+1, input$sel_raw_categ, "CORAL"))
    }),
  
  renderUI({
    shiny::req(!is.null(rv$raw_dat), !is.null(input$sel_raw_sitescale), !is.null(input$sel_raw_showRSS), !is.null(input$sel_raw_categ), !is.null(input$sel_raw_episodic))
    
    date_opts <- rv$raw_dat %>%
      dplyr::mutate(RSS = get(input$sel_raw_sitescale)) %>%
      dplyr::filter(
        RSS == input$sel_raw_showRSS,
        Category == input$sel_raw_categ,
        if(input$sel_raw_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
      dplyr::pull(SurvDate) %>%
      as.character()
    sliderTextInput("sel_raw_dates",
                label = "Compare % cover for two survey events (red lines on plots)",
                choices = date_opts,
                selected = c(min(date_opts, na.rm = TRUE), max(date_opts, na.rm = TRUE))
    )
  })

) # end of 'wp_raw_criteria'
```

% Cover per Transect
-------------------------------------

<h3>% Cover per Transect</h3>

###

```{r plot_transects}

output$out_transects_plot <- plotly::renderPlotly({
  shiny::validate(need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))

    shiny::req(!is.null(rv$raw_dat), !is.null(input$sel_raw_episodic), !is.null(input$sel_raw_showRSS), !is.null(input$sel_raw_sitescale), !is.null(input$sel_raw_categ), !is.null(rv$transect_counts_df), !is.null(input$sel_raw_dates))

  # Data to display in plots and table
  rv_param_temp$transects_subdat <- rv$raw_dat %>%
    dplyr::select(-Subcategory, -FunctionalGroup, -Taxon, -BleachingCode, -CountOfTaxon) %>%
    dplyr::mutate(RSS = get(input$sel_raw_sitescale),
                  Site_Transect = paste(Site, Transect, sep = "_")) %>%
    dplyr::filter(
      RSS == input$sel_raw_showRSS,
      Category == input$sel_raw_categ,
      if(input$sel_raw_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
    dplyr::distinct() %>%
    dplyr::left_join(rv$transect_counts_df, by = c("TransectSurveyID", "Category"))
  
  p <- ggplot(rv_param_temp$transects_subdat, aes(x = SurvDate, y = PercCov)) +
    geom_point() +
    geom_line() +
    geom_vline(xintercept = as.numeric(as.Date(input$sel_raw_dates)), color = "red") +
    theme_bw() +
    facet_wrap(vars(Site_Transect))
  ggplotly(p)
  })

tags$style("#out_transects_plot{height:100vh;overflow-x:scroll;overflow-y:scroll}")
plotlyOutput('out_transects_plot', height="100%", width = "100%")
```

### 

```{r}
output$out_compare_tab <- DT::renderDT({
  shiny::req(!is.null(rv_param_temp$transects_subdat), !is.null(input$sel_raw_dates))
  shiny::req(length(unique(input$sel_raw_dates)) == 2)

  compare_dat <- rv_param_temp$transects_subdat %>%
    dplyr::select(ReportingSite, Site, Transect, SurvDate, PercCov) %>%
    dplyr::mutate(SurvDate = as.character(SurvDate)) %>%
  dplyr::filter(SurvDate %in% input$sel_raw_dates)  %>%
  tidyr::pivot_wider(names_from = SurvDate, values_from = PercCov, names_prefix = "%Cover on ")

  compare_dat$`Change in %Cover` = compare_dat[5] - compare_dat[4]
  
  DT::datatable(
    compare_dat,
    class="compact stripe",
    rownames= FALSE,
    options = list(
      pageLength = 20,
      autoWidth = TRUE,
      dom = 'Bfrtip',
      buttons = c('copy', 'csv', 'excel', 'pdf'),
      columnDefs = list(list(className = 'dt_center', targets = "_all"))
      )
  )
})

dataTableOutput("out_compare_tab")
tags$style("#out_compare_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

% Cover & Relative Cover per Site
======================================  
Inputs {.sidebar data-width=300}
-------------------------------------
```{r input_cover_filter}
br()

h4("Data Filter Options")

# shinyjs::hidden( # initially hide this well panel
wellPanel(
  id = "wp_cover_criteria",

  # Pre-filter data
  checkboxInput("RSS_active", label = "Only use active sites", value = FALSE), #NOTE: Don't need switch() function to keep inputs from changing on these
  checkboxInput("sel_episodic", label = "Include episodic survey data", value = TRUE),
  
  # Select spatial scale--sites or reporting sites
  renderUI({
    radioButtons("sel_sitescale", 
             label = "Summarize data at this spatial scale:", 
             choiceNames = list("Reporting Site", "Site"),
             choiceValues = list("ReportingSite", "Site"),
             selected = switch(is.null(input$sel_sitescale)+1, input$sel_sitescale, "Site"),
             inline = TRUE)
    }),
  
  tags$div(renderText({
    shiny::req(!is.null(input$sel_sitescale))
    if(input$sel_sitescale == "ReportingSite") {
      paste0("NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites")  # Explain how reporting sites are summarized
      }
    }), style = "font-size:14px; color:red; font-weight:bold;"),
  
  renderUI({
    shiny::req(!is.null(rv$cover_CIs_df), !is.null(input$sel_sitescale), !is.null(input$RSS_active))
    
    RSS_choices <- rv$cover_CIs_df %>%
      dplyr::filter(if(input$RSS_active == TRUE) IsActive == 1 else TRUE) %>%
      {if(input$sel_sitescale == "Site") dplyr::pull(., Site) else dplyr::pull(., ReportingSite)} %>% unique(.)
    
    # Select (reporting) sites
    checkboxGroupInput("sel_showRSS", 
                       label = paste0("Show results for these ", if_else(input$sel_sitescale == "ReportingSite", "reporting sites", "sites")),
                       choices = RSS_choices, 
                       selected = if(!is.null(input$sel_showRSS) & all(input$sel_showRSS %in% RSS_choices)) {input$sel_showRSS} else {RSS_choices}, # if selections already made and they are a subset of RSS_choices, then use those selections; otherwise, use RSS_choices as default
                       inline = FALSE) 
    }),
  
  # Select numerator grouping scale for cover estimates
  renderUI({
    selectInput("sel_lev", 
                label = "Select grouping level", 
                choices = c("Category" = "Category", "Functional Group" = "FunctionalGroup", "Taxon" = "Taxon"),
                selected = switch(is.null(input$sel_lev)+1, input$sel_lev, "Category"))
    }),
  
  # If grouping option is finer than Category, then user must select a category to see the selection options for the finer grouping level
  
  renderUI({ # if estimating cover for a level other than Category, restrict summaries to a single Category
    shiny::req(!is.null(rv$cover_CIs_df), !is.null(input$sel_lev), !is.null(input$sel_showRSS))
    shiny::req(input$sel_lev != "Category")
    
    avail_categ <- sort(unique(rv$cover_CIs_df$Category[rv$cover_CIs_df$NumerGroup==input$sel_lev & rv$cover_CIs_df$RSS %in% input$sel_showRSS]))
    
    selectInput("sel_categ",
                label = paste0("Show ", input$sel_lev, " for this category"),
                choices = avail_categ,
                selected = switch(is.null(input$sel_categ)+1, input$sel_categ, "CORAL"))
    }),
  
  # Group levels to choose from (e.g., algae, coral...) for the selected grouping level. For Functional Group, only options are ALGAE and CORAL. For Taxon, options are ALGAE, CORAL, GORGO, SPONGE
  renderUI({
    shiny::req(!is.null(rv$groups_df), !is.null(input$sel_lev), !is.null(input$sel_sitescale), !is.null(input$sel_showRSS), !is.null(input$sel_episodic))
    
    rv_param_temp$avail_sublevs <- rv$cover_CIs_df %>%
      dplyr::filter(
        # SiteScale == input$sel_sitescale,
        RSS %in% input$sel_showRSS,
      NumerGroup == input$sel_lev) %>%
      dplyr::filter(if(input$sel_lev != "Category" & !is.null(input$sel_categ)) Category == input$sel_categ else TRUE) %>%
      dplyr::filter(if(input$sel_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
      pull(NumerLevel) %>%
      as.character() %>%
      unique() %>%
      sort()
      
  # sublev_default <- if_else("CORAL" %in% rv_param_temp$avail_sublevs, "CORAL", rv_param_temp$avail_sublevs[1])

  checkboxGroupInput("sel_sublev", 
                     label = "Select sublevel(s)",
                     choices = rv_param_temp$avail_sublevs, 
                     selected = if(!is.null(input$sel_sublev) & all(input$sel_sublev %in% rv_param_temp$avail_sublevs)) {input$sel_sublev} else {character(0)}, inline = TRUE)
  }),
  
  actionButton("sublev_all_button", "Select All", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  actionButton("sublev_none_button", "Select None", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  conditionalPanel(
    condition = "input.sel_lev == 'Taxon'",
    actionButton("sublev_esa_button", "Select ESA", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px")
    ), 

  br(),
  
  br(),
    
  actionButton("button_update_cover", "UPDATE COVER SUMMARIES", class = "green-action-button"),
  
  br(),
  
  br(),
  
  actionButton("button_export_PC", "Export Plot Data", class = "blue-action-button")
) # end of 'wp_cover_criteria'
```
 
```{r input_cover_format}

h4("Figure Format Options (plots update immediately)")

br()

renderUI({
  radioButtons("sel_error",
             label = "Bootstrapped error bars to plot",
             choiceNames = list("90%CI", "68%CI (~1SE)", "50%CI"),
             choiceValues = list("90%CI", "68%CI", "50%CI"),
             selected = switch(is.null(input$sel_error)+1, input$sel_error, "68%CI"),
             inline = TRUE)
})

renderUI({
  shiny::req(!is.null(input$sel_showRSS), !is.null(input$sel_sublev))

  selectInput("sel_splitplot", label = "In a single plot, show: ", choices = c("One sublevel, many locations" = "one_sub_many_loc", "One location, many sublevels" = "one_loc_many_sub", "One location, one sublevel" = "one_loc_one_sub"), selected = switch(is.null(input$sel_splitplot)+1, input$sel_splitplot, "one_sub_many_loc"), width = "95%")
})

renderUI({
  checkboxInput("PC_blackwhite", label = "Plot in grayscale (can only handle up to 6 categories)", value = switch(is.null(input$PC_blackwhite)+1, input$PC_blackwhite, FALSE))
})

checkboxInput("free_ymax", label = "Allow y-axes scales to vary among plots", value = TRUE)

```

% Cover & Relative Cover per Site
-------------------------------------

<div class="flex-container">
  <div class="flex-left">

<center><h3>% Cover per Site</h3></center>
<br>
```{r plot_PC}
output$out_cover_plot <- plotly::renderPlotly({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(
    need(!is.null(rv_param_temp$cover_subdat), message = "From 'Data Filter Options' on the left, please select a grouping level and sublevel(s), then press the green 'UPDATE COVER SUMMARIES' button"))
  
  shiny::req(!is.null(input$sel_splitplot), !is.null(input$PC_blackwhite), !is.null(input$sel_error), !is.null(rv_param_temp$sel_showRSS), !is.null(rv_param_temp$sel_sublev))

FuncPlotPointCI(dat = rv_param_temp$cover_subdat, denom = "TransectCount", sel_error = input$sel_error, sel_splitplot = input$sel_splitplot, free_ymax = input$free_ymax, y_text = paste0("Mean % Cover Per Transect (", input$sel_error, ")"), PC_blackwhite = input$PC_blackwhite)
  
})

plotlyOutput("out_cover_plot")
```

</div>
<div class="flex-right">

<center><h3>Relative Cover per Site</h3></center>
<br>
```{r plot_RC}
output$out_RC_plot <- plotly::renderPlotly({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(
    need(!is.null(rv_param_temp$cover_subdat), message = "Relative cover is estimated when the grouping level is 'Functional Group' or 'Taxon' with at least one selected sublevel. Press the green 'UPDATE COVER SUMMARIES' button after selection."))
  
  shiny::req(!is.null(input$sel_splitplot), !is.null(input$PC_blackwhite), !is.null(input$sel_error), !is.null(rv_param_temp$sel_showRSS), !is.null(rv_param_temp$sel_lev), !is.null(rv_param_temp$sel_sublev))
  
  shiny::validate(
    need(rv_param_temp$sel_lev!="Category", message = "Relative cover is estimated only when the grouping level is 'Functional Group' or 'Taxon'")
  )
  
  FuncPlotPointCI(dat = rv_param_temp$cover_subdat, denom = "CategoryCount", sel_error = input$sel_error, sel_splitplot = input$sel_splitplot, free_ymax = input$free_ymax, y_text = paste0("Mean % Relative Cover in Group (", input$sel_error, ")"), PC_blackwhite = input$PC_blackwhite)

})

plotlyOutput("out_RC_plot")
```
</div>
</div>

Coral Bleaching
======================================
Inputs {.sidebar data-width=300}
-------------------------------------
```{r input_bleach_filter}
br()

h4("Data Filter Options")

# shinyjs::hidden( # initially hide this well panel
wellPanel(
  id = "wp_bleach_criteria",
  
  # Pre-filter data
  checkboxInput("bleach_RSS_active", label = "Only use active sites", value = FALSE), 
  checkboxInput("sel_bleach_episodic", label = "Include episodic survey data", value = TRUE),
  
  # Select spatial scale--sites or reporting sites
  renderUI({
    radioButtons("sel_bleach_sitescale", 
                 label = "Summarize data at this spatial scale:", 
                 choiceNames = list("Reporting Site", "Site"),
                 choiceValues = list("ReportingSite", "Site"),
                 selected = switch(is.null(input$sel_bleach_sitescale)+1, input$sel_bleach_sitescale, "Site"),
                 inline = TRUE)
  }),
  
  tags$div(renderText({
    shiny::req(!is.null(input$sel_bleach_sitescale))
    if(input$sel_bleach_sitescale == "ReportingSite") {
      paste0("NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites")  # Explain how reporting sites are summarized
    }
  }), style = "font-size:14px;, !is. color:red; font-weight:bold;"),
  
  renderUI({
    shiny::req(!is.null(rv$bleach_CIs_df), !is.null(input$sel_bleach_sitescale), !is.null(input$bleach_RSS_active))
   
    bleach_RSS_choices <- rv$bleach_CIs_df %>%
      dplyr::filter(if(input$bleach_RSS_active == TRUE) IsActive == 1 else TRUE) %>%
      {if(input$sel_bleach_sitescale == "Site") dplyr::pull(., Site) else dplyr::pull(., ReportingSite)} %>% unique(.)
    
    # Select (reporting) site
    selectInput("sel_bleach_showRSS", 
                label = paste0("Show results for this ", if_else(input$sel_bleach_sitescale == "ReportingSite", "reporting site", "site")),
                choices = bleach_RSS_choices, 
                selected = switch(is.null(input$sel_bleach_showRSS)+1, input$sel_bleach_showRSS, bleach_RSS_choices[1]))
  })
) # end of 'wp_cover_criteria'
```
*\*To export a bleach plot, right-click on the plot and select 'Save image as'*
  
Column
-------------------------------------
### Coral Bleaching as % Cover of Site
  
```{r plot_bleachPC}
output$out_bleach_PC_plot <- plotly::renderPlotly({
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv$bleach_CIs_df), !is.null(input$bleach_RSS_active), !is.null(input$sel_bleach_episodic), !is.null(input$sel_bleach_sitescale), !is.null(input$sel_bleach_showRSS))

    # Data to display in plots and table
  rv_param_temp$bleach_subdat <- rv$bleach_CIs_df %>%
    dplyr::mutate(RSS = get(input$sel_bleach_sitescale),
                  Year = lubridate::year(SurvDate),
                  NumerLevel = factor(NumerLevel, levels = c("NONCORAL", "NoData", "UNBL", "BL1", "BL2", "BL3", "BL4"))) %>%
    dplyr::filter(
      RSS == input$sel_bleach_showRSS,
      if(input$sel_bleach_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
    arrange(SurvDate) %>%
    dplyr::mutate(SurvDate = as.factor(SurvDate))
  
  shiny::req(!is.null(rv_param_temp$bleach_subdat))

  plot_bleachPC <- FuncPlotBleach(dat = subset(rv_param_temp$bleach_subdat, DenomGroup == "TransectCount"), yaxis_title = "% Cover of Site")
    
  ggplotly(plot_bleachPC)
 
})
plotlyOutput("out_bleach_PC_plot")
```

### Coral Bleaching as % Cover of Corals
  
```{r plot_bleachRC}
output$out_bleach_RC_plot <- plotly::renderPlotly({
  
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv$bleach_CIs_df), !is.null(input$bleach_RSS_active), !is.null(input$sel_bleach_episodic), !is.null(input$sel_bleach_sitescale), !is.null(input$sel_bleach_showRSS))
  
  shiny::req(!is.null(rv_param_temp$bleach_subdat))
  
  plot_bleachRC <- FuncPlotBleach(dat = subset(rv_param_temp$bleach_subdat, DenomGroup == "CategoryCount"), yaxis_title = "% Cover of Corals")
    
  ggplotly(plot_bleachRC)
 
})
plotlyOutput("out_bleach_RC_plot")
```

All Bleaching Data
======================================

```{r}
output$out_bleach_tab <- DT::renderDT({
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv$bleach_CIs_df))
  
  DT::datatable(
    rv$bleach_CIs_df,
    class="compact stripe",
    rownames= FALSE,
    options = list(
      pageLength = 20,
      autoWidth = TRUE,
      dom = 'Bfrtip',
      buttons = c('copy', 'csv', 'excel', 'pdf'),
      columnDefs = list(list(className = 'dt_center', targets = "_all"))
      )
  )
})

dataTableOutput("out_bleach_tab")
tags$style("#out_bleach_tab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Coral Disease
======================================
Inputs {.sidebar data-width=300}
-------------------------------------
```{r input_disease_filter}
br()

h4("Data Filter Options")

# shinyjs::hidden( # initially hide this well panel
wellPanel(
  id = "wp_disease_criteria",
  
  # Pre-filter data
  checkboxInput("disease_RSS_active", label = "Only use active sites", value = FALSE), 
  checkboxInput("sel_disease_episodic", label = "Include episodic survey data", value = TRUE),
  
  # Select spatial scale--sites or reporting sites
  renderUI({
    radioButtons("sel_disease_sitescale", 
                 label = "Summarize data at this spatial scale:", 
                 choiceNames = list("Reporting Site", "Site"),
                 choiceValues = list("ReportingSite", "Site"),
                 selected = switch(is.null(input$sel_disease_sitescale)+1, input$sel_disease_sitescale, "Site"),
                 inline = TRUE)
  }),
  
  # tags$div(renderText({
  #   shiny::req(!is.null(input$sel_disease_sitescale))
  #   if(input$sel_disease_sitescale == "ReportingSite") {
  #     paste0("NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites")  # Explain how reporting sites are summarized
  #   }
  # }), style = "font-size:14px;, !is. color:red; font-weight:bold;"),
  
  renderUI({
    shiny::validate(need(!is.null(rv$disease_df), message = "No disease data found"))
    shiny::req(!is.null(input$sel_disease_sitescale), !is.null(input$disease_RSS_active))
   
    disease_RSS_choices <- rv$disease_df %>%
      dplyr::filter(if(input$disease_RSS_active == TRUE) IsActive == 1 else TRUE) %>%
      {if(input$sel_raw_sitescale == "Site") dplyr::pull(., Site) else dplyr::pull(., ReportingSite)} %>% unique(.)
    
    # Select (reporting) site
    selectInput("sel_disease_showRSS", 
                label = paste0("Show results for this ", if_else(input$sel_disease_sitescale == "ReportingSite", "reporting site", "site")),
                choices = disease_RSS_choices, 
                selected = switch(is.null(input$sel_disease_showRSS)+1, input$sel_disease_showRSS, disease_RSS_choices[1]))
  }),
  
  renderUI({
    shiny::validate(need(!is.null(rv$disease_df), message = "No disease data found"))
    shiny::req(!is.null(input$sel_disease_sitescale), !is.null(input$sel_disease_showRSS), !is.null(input$sel_disease_episodic))
    
    rv_param_temp$avail_diseases <- rv$disease_df %>%
      dplyr::rename(RSS = input$sel_disease_sitescale) %>%
      dplyr::filter(
        RSS %in% input$sel_disease_showRSS,
        if(input$sel_disease_episodic == FALSE) Purpose == "Annual" else TRUE) %>%
      pull(DiseaseCode) %>%
      unique() %>%
      sort()
    
    checkboxGroupInput("sel_diseases",
                       label = "Include these diseases",
                       choices = rv_param_temp$avail_diseases,
                       selected = if(!is.null(input$sel_diseases) & all(input$sel_diseases %in% rv_param_temp$avail_diseases)) {input$sel_diseases} else {character(0)}, inline = TRUE)
  }),
  
  actionButton("disease_all_button", "Select All", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  actionButton("disease_none_button", "Select None", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  actionButton("disease_tissue_loss_button", "Select Tissue Loss Diseases", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),
  
  actionButton("disease_discoloration_button", "Select Discoloration Diseases", style="background-color:#ededed; color:black; display:inline-block; border:1px solid #dcdcdc; padding: 3px"),

  br(),
  
  br(),

  actionButton("button_update_disease", "UPDATE DISEASE SUMMARIES", class = "green-action-button"),
  
  br(),
  
  br(),
  
  actionButton("button_export_disease", "Export Disease Data", class = "blue-action-button")
) # end of 'wp_disease_criteria'
```

*\*To export a disease plot, right-click on the plot and select 'Save image as'*
  
Column
-------------------------------------
### Disease Status of Coral Colonies, Summed Across Transects
  
```{r}
output$out_disease_plot <- plotly::renderPlotly({
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv_param_temp$disease_prev_site))

    # Data to display in plots and table
  disease_dat <- rv_param_temp$disease_prev_site %>%
    ungroup() %>%
    dplyr::select(Year, SurvDate, Diseased = SiteDiseased, NotDiseased = SiteNotDiseased) %>%
    tidyr::pivot_longer(cols = c("Diseased", "NotDiseased"), names_to = "DiseaseStatus", values_to = "NumColonies")

  plot_disease <- FuncPlotDiseaseSite(dat = disease_dat, y_col = "NumColonies", yaxis_title = "Number of coral colonies", subtitle_text = "Presence or absence of disease on coral colonies, summed across transects - FOR SELECTED DISEASES ONLY")
    
  ggplotly(plot_disease)
 
})
plotlyOutput("out_disease_plot")
```

### Disease Prevalence, Summed Across Transects
  
```{r}
output$out_disease_prev_plot <- plotly::renderPlotly({
  shiny::validate(
    need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::req(!is.null(rv_param_temp$disease_prev_site))

    # Data to display in plots and table
  disease_prev_dat <- rv_param_temp$disease_prev_site %>%
    ungroup() %>%
    dplyr::select(Year, SurvDate, SitePrev) %>%
    dplyr::mutate(
      Diseased = round(100 * SitePrev, 1),
      NotDiseased = round(100*(1 - SitePrev), 1))
  
  disease_prev_dat$Unknown <- ifelse(is.na(disease_prev_dat$SitePrev), 100, NA)
  disease_prev_dat %<>%
    tidyr::pivot_longer(cols = c("Diseased", "NotDiseased", "Unknown"), names_to = "DiseaseStatus", values_to = "PercentColonies")

  plot_disease <- FuncPlotDiseaseSite(dat = disease_prev_dat, y_col = "PercentColonies", yaxis_title = "% of colonies with disease", subtitle_text = "Disease prevalence, summed across transects - FOR SELECTED DISEASES ONLY")
    
  ggplotly(plot_disease)
 
})
plotlyOutput("out_disease_plot")
```
<<<<<<<<<<<<<<<<< PICK UP FROM HERE--TRANSECT PLOTS, THEN LESION METRICS. FIX UNEQUAL SPACING
Coral Maps
====================================== 
  Inputs {.sidebar data-width=200}
-------------------------------------
```{r map_input}
renderUI({
  shiny::req(!is.null(rv$bleach_CIs_df))
  sliderTextInput("sel_map_event", force_edges = TRUE, animate = TRUE, label = "Choose a survey event", choices = sort(as.character(unique(rv$bleach_CIs_df$SurvDate))), selected = , dragRange = FALSE, width = "95%")
  })

checkboxInput("sel_map_active", label = "Show active sites only", value = FALSE)

radioButtons("sel_map_metric", 
             label = "Metric to map:", 
             choiceNames = list("% coral cover", "bleaching relative cover"),
             choiceValues = list("coral_pc", "bleach_rc"),
             selected = "coral_pc")
```

Column {data-width=550 vertical_layout: fill}
-------------------------------------
*NOTE:  For surveys from Oct. 2005 to present, coral data with NA entry for 'Bleaching Code' are considered 'Unbleached' (UNBL)*
```{r maps}
output$coral_map = renderLeaflet({
  
  shiny::validate(need(!is.null(rv$raw_dat), message = "Please import new data or load an existing summary RDS file"))
  
  shiny::validate(need(!is.null(rv$map_dat), message = "Map data have not been processed."))
  
  shiny::req(!is.null(input$sel_map_active), !is.null(input$sel_map_metric), !is.null(input$sel_map_event))
    
    map_df <- rv$map_dat %>%
      dplyr::filter(if(input$sel_map_active == TRUE) IsActive == 1 else TRUE)
    
    shiny::req(nrow(map_df) > 0)
    
    min_long <- min(map_df$MedLong, na.rm = TRUE)
    min_lat <- min(map_df$MedLat, na.rm = TRUE)
    max_long <- max(map_df$MedLong, na.rm = TRUE)
    max_lat <- max(map_df$MedLat, na.rm = TRUE)
    
    map_df %<>%
      dplyr::filter(SurvDate == input$sel_map_event) %>%
      select(-c(ReportingSiteName, ReportingSite, IsActive, MinYr, MaxYr))
  
    chartmap <- leaflet() %>%
      addProviderTiles("Esri.NatGeoWorldMap", options = providerTileOptions(noWrap = TRUE)) %>%
      addControl(HTML(switch(input$sel_map_metric, "coral_pc" = "% Cover coral", "bleach_rc" = "Coral bleaching relative cover"), " on: ", input$sel_map_event), position = "topleft", className="map-title") %>%
      addScaleBar() %>% 
      leaflet.minicharts::addMinicharts(
          lng = map_df$MedLong,
          lat = map_df$MedLat,
          time = map_df$SurvDate,
          type = "pie",
          width = switch(input$sel_map_metric,
                         "coral_pc" = 25,
                         "bleach_rc" = 5*map_df$`%Coral`), 
          height = switch(input$sel_map_metric,
                         "coral_pc" = 25,
                         "bleach_rc" = NA), 
          transitionTime = 0, 
          layerId = map_df$PopText,
          chartdata = switch(input$sel_map_metric,
                         "coral_pc" = as.matrix(map_df[, c("%Coral", "%NonCoral")]),
                         "bleach_rc" = as.matrix(map_df[, c("NoData", "UNBL", "BL1", "BL2", "BL3", "BL4")])), 
          colorPalette = switch(input$sel_map_metric,
                         "coral_pc" = c("red", "gray"),
                         "bleach_rc" = c("#FFFF00", "#404040", "#737373", "#8C8C8C", "#BFBFBF", "#EBEBEB")),
          opacity = .85) 
})
leafletOutput('coral_map', height=600)
```